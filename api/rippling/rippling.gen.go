// Package rippling provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/deepmap/oapi-codegen version v1.10.1 DO NOT EDIT.
package rippling

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"encoding/xml"
	"errors"
	"fmt"
	"gopkg.in/yaml.v2"
	"io"
	"io/ioutil"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/deepmap/oapi-codegen/pkg/runtime"
	openapi_types "github.com/deepmap/oapi-codegen/pkg/types"
	"github.com/getkin/kin-openapi/openapi3"
	"github.com/go-chi/chi/v5"
	"github.com/labstack/echo/v4"
)

const (
Bearer_ApiKeyScopes = "Bearer_ApiKey.Scopes"
AuthorizationCodeScopes = "authorizationCode.Scopes"

)





// Defines values for CandidateEmploymentType.
const (

  CandidateEmploymentTypeCONTRACTOR CandidateEmploymentType = "CONTRACTOR"

  CandidateEmploymentTypeHOURLYFT CandidateEmploymentType = "HOURLY_FT"

  CandidateEmploymentTypeHOURLYPT CandidateEmploymentType = "HOURLY_PT"

  CandidateEmploymentTypeSALARIEDFT CandidateEmploymentType = "SALARIED_FT"

  CandidateEmploymentTypeSALARIEDPT CandidateEmploymentType = "SALARIED_PT"

  CandidateEmploymentTypeTEMP CandidateEmploymentType = "TEMP"

)

// Defines values for CandidateSalaryUnit.
const (

  CandidateSalaryUnitDAY CandidateSalaryUnit = "DAY"

  CandidateSalaryUnitHOUR CandidateSalaryUnit = "HOUR"

  CandidateSalaryUnitMONTH CandidateSalaryUnit = "MONTH"

  CandidateSalaryUnitPAYPERIOD CandidateSalaryUnit = "PAY_PERIOD"

  CandidateSalaryUnitWEEK CandidateSalaryUnit = "WEEK"

)

// Defines values for CustomFieldsType.
const (

  CustomFieldsTypeCURRENCY CustomFieldsType = "CURRENCY"

  CustomFieldsTypeDATE CustomFieldsType = "DATE"

  CustomFieldsTypeFILE CustomFieldsType = "FILE"

  CustomFieldsTypeID CustomFieldsType = "ID"

  CustomFieldsTypeNUMBER CustomFieldsType = "NUMBER"

  CustomFieldsTypePERCENTAGE CustomFieldsType = "PERCENTAGE"

  CustomFieldsTypeRADIO CustomFieldsType = "RADIO"

  CustomFieldsTypeSELECT CustomFieldsType = "SELECT"

  CustomFieldsTypeTEXT CustomFieldsType = "TEXT"

  CustomFieldsTypeTEXTAREA CustomFieldsType = "TEXTAREA"

)

// Defines values for EmployeeEmploymentType.
const (

  EmployeeEmploymentTypeCONTRACTOR EmployeeEmploymentType = "CONTRACTOR"

  EmployeeEmploymentTypeHOURLYFT EmployeeEmploymentType = "HOURLY_FT"

  EmployeeEmploymentTypeHOURLYPT EmployeeEmploymentType = "HOURLY_PT"

  EmployeeEmploymentTypeSALARIEDFT EmployeeEmploymentType = "SALARIED_FT"

  EmployeeEmploymentTypeSALARIEDPT EmployeeEmploymentType = "SALARIED_PT"

  EmployeeEmploymentTypeTEMP EmployeeEmploymentType = "TEMP"

)

// Defines values for EmployeeGender.
const (

  EmployeeGenderFEMALE EmployeeGender = "FEMALE"

  EmployeeGenderMALE EmployeeGender = "MALE"

  EmployeeGenderNil EmployeeGender = "<nil>"

)

// Defines values for EmployeeIdentifiedGender.
const (

  EmployeeIdentifiedGenderFEMALE EmployeeIdentifiedGender = "FEMALE"

  EmployeeIdentifiedGenderMALE EmployeeIdentifiedGender = "MALE"

  EmployeeIdentifiedGenderNONBINARY EmployeeIdentifiedGender = "NONBINARY"

  EmployeeIdentifiedGenderNil EmployeeIdentifiedGender = "<nil>"

)

// Defines values for EmployeeRoleState.
const (

  EmployeeRoleStateACCEPTED EmployeeRoleState = "ACCEPTED"

  EmployeeRoleStateACTIVE EmployeeRoleState = "ACTIVE"

  EmployeeRoleStateHIRED EmployeeRoleState = "HIRED"

  EmployeeRoleStateINIT EmployeeRoleState = "INIT"

  EmployeeRoleStateTERMINATED EmployeeRoleState = "TERMINATED"

)

// Defines values for EventEventType.
const (

  EventEventTypeACCOUNTPASSWORDCHANGED EventEventType = "ACCOUNT_PASSWORD_CHANGED"

  EventEventTypeACCOUNTPASSWORDRESET EventEventType = "ACCOUNT_PASSWORD_RESET"

  EventEventTypeEXTERNALACCOUNTCREATE EventEventType = "EXTERNAL_ACCOUNT_CREATE"

  EventEventTypeEXTERNALACCOUNTDELETE EventEventType = "EXTERNAL_ACCOUNT_DELETE"

  EventEventTypeEXTERNALACCOUNTINVITE EventEventType = "EXTERNAL_ACCOUNT_INVITE"

  EventEventTypeEXTERNALACCOUNTPASSWORDRESET EventEventType = "EXTERNAL_ACCOUNT_PASSWORD_RESET"

  EventEventTypeEXTERNALACCOUNTSUSPEND EventEventType = "EXTERNAL_ACCOUNT_SUSPEND"

  EventEventTypeEXTERNALGROUPADD EventEventType = "EXTERNAL_GROUP_ADD"

  EventEventTypeEXTERNALGROUPMEMBERREMOVE EventEventType = "EXTERNAL_GROUP_MEMBER_REMOVE"

  EventEventTypeEXTERNALGROUPREMOVE EventEventType = "EXTERNAL_GROUP_REMOVE"

  EventEventTypeEXTERNALSSOGRANT EventEventType = "EXTERNAL_SSO_GRANT"

  EventEventTypeEXTERNALSSOREVOKE EventEventType = "EXTERNAL_SSO_REVOKE"

  EventEventTypeEXTERNALSSOSIGNIN EventEventType = "EXTERNAL_SSO_SIGNIN"

  EventEventTypeRPASSITEMSHARED EventEventType = "RPASS_ITEM_SHARED"

  EventEventTypeRPASSITEMUNSHARED EventEventType = "RPASS_ITEM_UNSHARED"

  EventEventTypeRPASSITEMUSED EventEventType = "RPASS_ITEM_USED"

  EventEventTypeTWOFACTORDEVICERESET EventEventType = "TWO_FACTOR_DEVICE_RESET"

  EventEventTypeUSERLOGINFAILED EventEventType = "USER_LOGIN_FAILED"

  EventEventTypeUSERLOGINSUCCESS EventEventType = "USER_LOGIN_SUCCESS"

)

// Defines values for EventInitiatorType.
const (

  EventInitiatorTypeEXTERNAL EventInitiatorType = "EXTERNAL"

  EventInitiatorTypeROLE EventInitiatorType = "ROLE"

  EventInitiatorTypeSYSTEM EventInitiatorType = "SYSTEM"

)

// Defines values for EventSubjectsType.
const (

  EventSubjectsTypeGROUP EventSubjectsType = "GROUP"

  EventSubjectsTypeROLE EventSubjectsType = "ROLE"

  EventSubjectsTypeRPASSITEM EventSubjectsType = "RPASS_ITEM"

  EventSubjectsTypeSPOKE EventSubjectsType = "SPOKE"

  EventSubjectsTypeSPOKEUSER EventSubjectsType = "SPOKE_USER"

)

// Defines values for LeaveRequestLeaveType.
const (

  LeaveRequestLeaveTypeJURYDUTY LeaveRequestLeaveType = "JURY_DUTY"

  LeaveRequestLeaveTypeSICK LeaveRequestLeaveType = "SICK"

  LeaveRequestLeaveTypeVACATION LeaveRequestLeaveType = "VACATION"

)

// Defines values for LeaveRequestStatus.
const (

  LeaveRequestStatusAPPROVED LeaveRequestStatus = "APPROVED"

  LeaveRequestStatusCANCELED LeaveRequestStatus = "CANCELED"

  LeaveRequestStatusPENDING LeaveRequestStatus = "PENDING"

  LeaveRequestStatusREJECTED LeaveRequestStatus = "REJECTED"

)



// An address object as stored within Rippling.
type Address  struct {
    City *string`json:"city,omitempty"`
    Country *string`json:"country,omitempty"`
    State *string`json:"state,omitempty"`
    StreetLine1 *string`json:"streetLine1,omitempty"`
    StreetLine2 *string`json:"streetLine2,omitempty"`
    Zip *string`json:"zip,omitempty"`
}

// Information about the Rippling user whose token is being used to access Rippling's API.
type AuthenticatedUserMe  struct {
// Unique identifier of the company.
    Company *string`json:"company,omitempty"`

// Unied identifier of the user (likely an admin).
    Id *string`json:"id,omitempty"`

// Work email of the user.
    WorkEmail *string`json:"workEmail,omitempty"`
}

// The Rippling candidate model.
type Candidate  struct {
    Attachments *[]struct {
// The file name.
    FileName *string`json:"file_name,omitempty"`

// The public URL and name of a pdf/docx/doc/odt file containing documents pertaining to the candidate.
    FileUrl *string`json:"file_url,omitempty"`
}`json:"attachments,omitempty"`

// The unique identifier of the candidate from the ATS.
    CandidateId *string`json:"candidateId,omitempty"`

// A string field of the ofifcial currency doe as listed in ISO 4217.
    Currency *string`json:"currency,omitempty"`

// The department name as a string.
    Department *string`json:"department,omitempty"`

// The candidate's email.
    Email *string`json:"email,omitempty"`

// The ENUM type of employment the user will have within Rippling.
    EmploymentType *CandidateEmploymentType`json:"employmentType,omitempty"`

// The number of shares that will be given to the candidate.
    EquityShares *int`json:"equityShares,omitempty"`

// The candidate's job title.
    JobTitle *string`json:"jobTitle,omitempty"`

// The candidate's name.
    Name *string`json:"name,omitempty"`

// The candidate's phone number.
    PhoneNumber *string`json:"phoneNumber,omitempty"`

// The decimal value that the candidate gets paid every salaryUnit time period.
    SalaryPerUnit *float32`json:"salaryPerUnit,omitempty"`

// An ENUM string value, denoting the frequency at which the candidate should be paid once the role begins. Note, the PAY_PERIOD ENUM implies the candidate is paid as per a custom pay period.
    SalaryUnit *CandidateSalaryUnit`json:"salaryUnit,omitempty"`

// The bonus cash given to the candidate as a part of a one time payment, with two decimal digit precision.
    SigningBonus *float64`json:"signingBonus,omitempty"`

// The would-be start date of the candidate.
    StartDate *openapi_types.Date`json:"startDate,omitempty"`
}

// The ENUM type of employment the user will have within Rippling.
type CandidateEmploymentType  string

// An ENUM string value, denoting the frequency at which the candidate should be paid once the role begins. Note, the PAY_PERIOD ENUM implies the candidate is paid as per a custom pay period.
type CandidateSalaryUnit  string

// A company object as represented within Rippling.
type Company  struct {
// An address object as stored within Rippling.
    Address *Address`json:"address"`
    Id *string`json:"id,omitempty"`
    Name *string`json:"name,omitempty"`
    Phone *string`json:"phone,omitempty"`
    PrimaryEmail *string`json:"primaryEmail,omitempty"`
    WorkLocations *[]WorkLocation`json:"workLocations,omitempty"`
}

// A Custom Fields object within Rippling.
type CustomFields  struct {
// The identifier of the specific custom field.
    Id *string`json:"Id,omitempty"`

// Denotes whether the custom field is or is not mandatory
    Required *bool`json:"required,omitempty"`

// The title of the custom field.
    Title *string`json:"title,omitempty"`

// Denotes the type of the custom field.
    Type *CustomFieldsType`json:"type,omitempty"`
}

// Denotes the type of the custom field.
type CustomFieldsType  string

// A company department object.
type Department  struct {
// Name of the department
    Name *string`json:"name,omitempty"`

// Id of the parent department, if one exists
    Parent *string`json:"parent"`
}

// An employee model object.
type Employee  struct {
// A Custom Fields object within Rippling.
    CustomFields *CustomFields`json:"customFields,omitempty"`

// The employee's department name
    Department *string`json:"department,omitempty"`

// An ENUM of employment type
    EmploymentType *EmployeeEmploymentType`json:"employmentType,omitempty"`

// The employee's end date
    EndDate *string`json:"endDate"`

// First name of the employee
    FirstName *string`json:"firstName,omitempty"`

// The employee's gender
    Gender *EmployeeGender`json:"gender,omitempty"`

// Unique Employee Identifier 
    Id *string`json:"id,omitempty"`

// The employee's identified gender
    IdentifiedGender *EmployeeIdentifiedGender`json:"identifiedGender,omitempty"`

// Last name of the employee
    LastName *string`json:"lastName,omitempty"`

// The unique identifier of the employee's manager. This value can be null.
    Manager *string`json:"manager,omitempty"`

// Full name of the employee
    Name *string`json:"name,omitempty"`

// The employee's role status - roleState meanings:
// 
// INIT: An initial record of an individual. An offer has not been made and they have not started working at the company.
// 
// HIRED: An offer has been made but they have not accepted or started yet.
// 
// ACCEPTED: An offer has been made and they have accepted, but they have not started yet.
// 
// ACTIVE: The employee currently works at the company and their start date is today or in the past.
// 
// TERMINATED: The employee is no longer active.
    RoleState *EmployeeRoleState`json:"roleState,omitempty"`
    SpokeId *string`json:"spokeId"`

// The employee's work title
    Title *string`json:"title,omitempty"`

// The employee's work email
    WorkEmail *string`json:"workEmail"`

// An address object as stored within Rippling.
    WorkLocation *Address`json:"workLocation"`
}

// An ENUM of employment type
type EmployeeEmploymentType  string

// The employee's gender
type EmployeeGender  string

// The employee's identified gender
type EmployeeIdentifiedGender  string

// The employee's role status - roleState meanings:
// 
// INIT: An initial record of an individual. An offer has not been made and they have not started working at the company.
// 
// HIRED: An offer has been made but they have not accepted or started yet.
// 
// ACCEPTED: An offer has been made and they have accepted, but they have not started yet.
// 
// ACTIVE: The employee currently works at the company and their start date is today or in the past.
// 
// TERMINATED: The employee is no longer active.
type EmployeeRoleState  string

// The event model for company activity.
// 
// Please note, the event type can be one of the following:
// 
// - EXTERNAL_ACCONT_CREATE
// - EXTERNAL_ACCOUNT_INVITE
// - EXTERNAL_ACCOUNT_DELETE
// - EXTERNAL_ACCOUNT_SUSPEND
// - EXTERNAL_ACCOUNT_PASSWORD_RESET
// - EXTERNAL_GROUP_ADD
// - EXTERNAL_GROUP_REMOVE
// - EXTERNAL_GROUP_MEMBER_REMOVE
// - EXTERNAL_GROUP_MEMBER_ADD
// - EXTERNAL_SSO_GRANT
// - EXTERNAL_SSO_REVOKE
// - EXTERNAL_SSO_SIGNIN
// - RPASS_ITEM_SHARED
// - RPASS_ITEM_UNSHARED
// - RPASS_ITEM_USED
// - USER_LOGIN_SUCCESS
// - USER_LOGIN_FAILED
// - ACCOUNT_PASSWORD_RESET
// - ACCOUNT_PASSWORD_CHANGED
// - TWO_FACTOR_DEVICE_RESET
type Event  struct {
// Unique identifier for the company.
    Company *string`json:"company,omitempty"`

// Reason for the event, tied to the type of eveent.
    EventReason *struct {
// Message of the event.
    Message *string`json:"message,omitempty"`

// Reason for the event.
    Reason *string`json:"reason,omitempty"`
}`json:"event_reason"`

// An ENUM value for the type of the event.
    EventType *EventEventType`json:"event_type,omitempty"`

// Unique identifier of the event.
    Id *string`json:"id,omitempty"`

// The actor of the event.
    Initiator *struct {
// The name used within Rippling.
    DisplayName *string`json:"display_name,omitempty"`

// The icon used within Rippling.
    Icon *string`json:"icon"`

// A unique identifier for the employee that initiated the action, if the type is ROLE.
    Role *string`json:"role"`

// ENUM value for the type of actor.
    Type *EventInitiatorType`json:"type,omitempty"`
}`json:"initiator"`

// An array of event identifiers that are linked to the event.
    LinkedEvents *[]string`json:"linked_events,omitempty"`

// Display name for the event, tied to the type of event.
    Name *string`json:"name,omitempty"`

// Geographic details from where the event was recorded.
    RequestData *struct {
// City the event was triggered from.
    City *string`json:"city,omitempty"`

// Country the event was triggered from.
    Country *string`json:"country,omitempty"`

// Event IP addresss.
    Ip *string`json:"ip,omitempty"`

// Latitude the event was triggered from.
    Latitude *string`json:"latitude,omitempty"`

// Longitude the event was triggered from.
    Longitude *string`json:"longitude,omitempty"`
}`json:"request_data"`

// Unique identifier for the external application for which the event was recorded. This will be Null for events that don't correspond to an external appliction (e.g. Rippling system and RPass events).
    Spoke *string`json:"spoke"`

// The list of objects of the event.
    Subjects *[]struct {
// Name used within Rippling.
    DisplayName *string`json:"display_name,omitempty"`

// Icon used within Rippling.
    Icon *string`json:"icon"`

// Unique key for the event object.
    Instance *string`json:"instance,omitempty"`

// An ENUM value for the type of object.
    Type *EventSubjectsType`json:"type,omitempty"`
}`json:"subjects,omitempty"`

// Timestamp at which the event was recorded.
    Timestamp *string`json:"timestamp,omitempty"`
}

// An ENUM value for the type of the event.
type EventEventType  string

// ENUM value for the type of actor.
type EventInitiatorType  string

// An ENUM value for the type of object.
type EventSubjectsType  string

// Group defines model for Group.
type Group  struct {
    Id *string`json:"id,omitempty"`

// User-readable name of a Rippling group.
    Name *string`json:"name,omitempty"`

// Your id for the group; this should a unique string identifier.
    SpokeId *string`json:"spokeId"`

// An array of employee Rippling ids.
    Users *[]string`json:"users,omitempty"`

// The version unique identifier of the group.
    Version *string`json:"version,omitempty"`
}

// This payload should be used when updating existing groups.
type GroupUpdatePayload  struct {
// The name of the Group.
    Name *string`json:"name,omitempty"`

// The external identifier of the Group.
    SpokeId *string`json:"spokeId,omitempty"`

// The array of users within the Group.
    Users *[]interface{}`json:"users,omitempty"`

// The version identifier of the Group.
    Version *string`json:"version,omitempty"`
}

// Leave request object.
type LeaveRequest  struct {
    Comments *string`json:"comments"`
    CreatedAt *string`json:"createdAt,omitempty"`
    Dates *[]struct {
    Date *openapi_types.Date`json:"date,omitempty"`
    NumMinutes *int`json:"numMinutes,omitempty"`
}`json:"dates,omitempty"`
    EndDate *string`json:"endDate,omitempty"`

// Unique identifier of the leave request.
    Id *string`json:"id,omitempty"`
    LeavePolicy *string`json:"leavePolicy,omitempty"`
    LeaveType *LeaveRequestLeaveType`json:"leaveType,omitempty"`
    NumHours *int`json:"numHours"`
    NumMinutes *int`json:"numMinutes"`
    PolicyDisplayName *string`json:"policyDisplayName,omitempty"`
    ProcessedAt *string`json:"processedAt,omitempty"`

// Unique identifier of the employee who approved or rejected the request. This may be null.
    ProcessedBy *string`json:"processedBy,omitempty"`
    ProcessedByName *string`json:"processedByName,omitempty"`
    ReasonForLeave *string`json:"reasonForLeave,omitempty"`
    RequestedBy *string`json:"requestedBy,omitempty"`

// Unique identifier of the employee who made the request (in most cases this is the same as role).
    RequestedByName *string`json:"requestedByName,omitempty"`

// Unique identifier of the employee who is taking leave.
    Role *string`json:"role,omitempty"`
    RoleName *string`json:"roleName,omitempty"`
    StartDate *string`json:"startDate,omitempty"`
    Status *LeaveRequestStatus`json:"status,omitempty"`
    UpdatedAt *string`json:"updatedAt,omitempty"`
}

// LeaveRequestLeaveType defines model for LeaveRequest.LeaveType.
type LeaveRequestLeaveType  string

// LeaveRequestStatus defines model for LeaveRequest.Status.
type LeaveRequestStatus  string

// Levels enable for self-defined,company-wide position levels, such as Manager, Engineering Manager, Executive, etc.
type Level  struct {
// Unique identifier of the level.
    Id *string`json:"id,omitempty"`

// Name of the level.
    Name *string`json:"name,omitempty"`

// The unique identifier of the parent level.
    Parent *string`json:"parent"`
}

// A team is a self-defined group of employees within Rippling.
type Team  struct {
// The identifier of the team.
    Id *string`json:"id,omitempty"`

// The name of the team.
    Name *string`json:"name,omitempty"`

// The parent team (if this team is a subteam within a larger team).
    Parent *string`json:"parent"`
}

// A work location object.
type WorkLocation  struct {
// An address object as stored within Rippling.
    Address *Address`json:"address"`
    Nickname *string`json:"nickname,omitempty"`
}

// Ein defines model for ein.
type Ein  int

// EmployeeId defines model for employeeId.
type EmployeeId  int

// GroupId defines model for groupId.
type GroupId  int

// Limit defines model for limit.
type Limit  int

// Offset defines model for offset.
type Offset  int



// PostAtsCandidatesPushCandidateJSONBody defines parameters for PostAtsCandidatesPushCandidate.
type PostAtsCandidatesPushCandidateJSONBody  Candidate





// GetCompanyActivityParams defines parameters for GetCompanyActivity.
type GetCompanyActivityParams  struct {
// Timestamp to list activity after (inclusive). This should be less than 90 days from now. Defaults to 90 days.
    StartDate *openapi_types.Date`json:"startDate,omitempty"`

// Timestamp to list activity before (inclusive).
    EndDate *openapi_types.Date`json:"endDate,omitempty"`

// Specifies the pagination cursor to the next page
    Next *string`json:"next,omitempty"`

// Specifies the number of results to page (maximum: 1000) (default: 1000)
    Limit *string`json:"limit,omitempty"`
}



// GetCustomFieldsParams defines parameters for GetCustomFields.
type GetCustomFieldsParams  struct {
// Sets a limit on the returned values
    Limit *Limit`json:"limit,omitempty"`

// Offsets the returned values
    Offset *Offset`json:"offset,omitempty"`
}



// GetDepartmentsParams defines parameters for GetDepartments.
type GetDepartmentsParams  struct {
// Sets a limit on the returned values
    Limit *Limit`json:"limit,omitempty"`

// Offsets the returned values
    Offset *Offset`json:"offset,omitempty"`
}



// GetEmployeesParams defines parameters for GetEmployees.
type GetEmployeesParams  struct {
// Sets a limit on the returned values
    Limit *Limit`json:"limit,omitempty"`

// Offsets the returned values
    Offset *Offset`json:"offset,omitempty"`
}



// GetEmployeesIncludeTerminatedParams defines parameters for GetEmployeesIncludeTerminated.
type GetEmployeesIncludeTerminatedParams  struct {
// Sets a limit on the returned values
    Limit *Limit`json:"limit,omitempty"`

// Offsets the returned values
    Offset *Offset`json:"offset,omitempty"`

// Employer identification number, also known as the Federal Emplower Identification Number or the Federal Tax Identification Number.
    EIN *Ein`json:"EIN,omitempty"`
}







// PostGroupsJSONBody defines parameters for PostGroups.
type PostGroupsJSONBody  struct {
// User-readable name of the group.
    Name *string`json:"name,omitempty"`

// The unique ID for the group, this can be the unique identifier for the group entity object within your application.
    SpokeId *string`json:"spokeId,omitempty"`

// An array of Rippling IDs that will be in the group.
    Users *[]string`json:"users,omitempty"`
}





// PatchGroupsGroupIdJSONBody defines parameters for PatchGroupsGroupId.
type PatchGroupsGroupIdJSONBody  GroupUpdatePayload



// PutGroupsGroupIdJSONBody defines parameters for PutGroupsGroupId.
type PutGroupsGroupIdJSONBody  GroupUpdatePayload



// GetLeaveRequestsParams defines parameters for GetLeaveRequests.
type GetLeaveRequestsParams  struct {
    Id *string`json:"id,omitempty"`
    Role *string`json:"role,omitempty"`
    RequestedBy *string`json:"requestedBy,omitempty"`
    Status *string`json:"status,omitempty"`

// Start date of leave.
    StartDate *string`json:"startDate,omitempty"`

// End date of leave.
    EndDate *string`json:"endDate,omitempty"`
    LeavePolicy *string`json:"leavePolicy,omitempty"`
    ProcessedBy *string`json:"processedBy,omitempty"`

// Filter to capture whether the leave request overlaps with a date range.
    From *string`json:"from,omitempty"`

// Filter to capture whether the leave request overlaps with a date range.
    To *string`json:"to,omitempty"`
}



// ProcessLeaveRequestsParams defines parameters for ProcessLeaveRequests.
type ProcessLeaveRequestsParams  struct {
// The action to be taken on the leave request. Can be either approved or declined.
    Action ProcessLeaveRequestsParamsAction`json:"action"`
}

// ProcessLeaveRequestsParamsAction defines parameters for ProcessLeaveRequests.
type ProcessLeaveRequestsParamsAction  string



// GetLevelsParams defines parameters for GetLevels.
type GetLevelsParams  struct {
// Sets a limit on the returned values
    Limit *Limit`json:"limit,omitempty"`

// Offsets the returned values
    Offset *Offset`json:"offset,omitempty"`
}









// GetTeamsParams defines parameters for GetTeams.
type GetTeamsParams  struct {
// Sets a limit on the returned values
    Limit *Limit`json:"limit,omitempty"`

// Offsets the returned values
    Offset *Offset`json:"offset,omitempty"`
}



// GetWorkLocationsParams defines parameters for GetWorkLocations.
type GetWorkLocationsParams  struct {
// Sets a limit on the returned values
    Limit *Limit`json:"limit,omitempty"`

// Offsets the returned values
    Offset *Offset`json:"offset,omitempty"`
}






// PostAtsCandidatesPushCandidateJSONRequestBody defines body for PostAtsCandidatesPushCandidate for application/json ContentType.
type PostAtsCandidatesPushCandidateJSONRequestBody  PostAtsCandidatesPushCandidateJSONBody





















// PostGroupsJSONRequestBody defines body for PostGroups for application/json ContentType.
type PostGroupsJSONRequestBody  PostGroupsJSONBody







// PatchGroupsGroupIdJSONRequestBody defines body for PatchGroupsGroupId for application/json ContentType.
type PatchGroupsGroupIdJSONRequestBody  PatchGroupsGroupIdJSONBody





// PutGroupsGroupIdJSONRequestBody defines body for PutGroupsGroupId for application/json ContentType.
type PutGroupsGroupIdJSONRequestBody  PutGroupsGroupIdJSONBody






















// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
    // create a client with sane default values
    client := Client{
        Server: server,
    }
    // mutate client and add all optional params
    for _, o := range opts {
        if err := o(&client); err != nil {
            return nil, err
        }
    }
    // ensure the server URL always has a trailing slash
    if !strings.HasSuffix(client.Server, "/") {
        client.Server += "/"
    }
    // create httpClient, if not already present
    if client.Client == nil {
        client.Client = &http.Client{}
    }
    return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
// PostAtsCandidatesPushCandidate request with any body
    PostAtsCandidatesPushCandidateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*http.Response, error)

    PostAtsCandidatesPushCandidate(ctx context.Context, body PostAtsCandidatesPushCandidateJSONRequestBody, reqEditors... RequestEditorFn) (*http.Response, error)

// GetCompanies request
    GetCompanies(ctx context.Context, reqEditors... RequestEditorFn) (*http.Response, error)

// GetCompanyActivity request
    GetCompanyActivity(ctx context.Context, params *GetCompanyActivityParams, reqEditors... RequestEditorFn) (*http.Response, error)

// GetCustomFields request
    GetCustomFields(ctx context.Context, params *GetCustomFieldsParams, reqEditors... RequestEditorFn) (*http.Response, error)

// GetDepartments request
    GetDepartments(ctx context.Context, params *GetDepartmentsParams, reqEditors... RequestEditorFn) (*http.Response, error)

// GetEmployees request
    GetEmployees(ctx context.Context, params *GetEmployeesParams, reqEditors... RequestEditorFn) (*http.Response, error)

// GetEmployeesIncludeTerminated request
    GetEmployeesIncludeTerminated(ctx context.Context, params *GetEmployeesIncludeTerminatedParams, reqEditors... RequestEditorFn) (*http.Response, error)

// GetEmployeesEmployeeId request
    GetEmployeesEmployeeId(ctx context.Context, employeeId EmployeeId, reqEditors... RequestEditorFn) (*http.Response, error)

// GetGroups request
    GetGroups(ctx context.Context, reqEditors... RequestEditorFn) (*http.Response, error)

// PostGroups request with any body
    PostGroupsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*http.Response, error)

    PostGroups(ctx context.Context, body PostGroupsJSONRequestBody, reqEditors... RequestEditorFn) (*http.Response, error)

// DeleteGroupsGroupId request
    DeleteGroupsGroupId(ctx context.Context, groupId GroupId, reqEditors... RequestEditorFn) (*http.Response, error)

// PatchGroupsGroupId request with any body
    PatchGroupsGroupIdWithBody(ctx context.Context, groupId GroupId, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*http.Response, error)

    PatchGroupsGroupId(ctx context.Context, groupId GroupId, body PatchGroupsGroupIdJSONRequestBody, reqEditors... RequestEditorFn) (*http.Response, error)

// PutGroupsGroupId request with any body
    PutGroupsGroupIdWithBody(ctx context.Context, groupId GroupId, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*http.Response, error)

    PutGroupsGroupId(ctx context.Context, groupId GroupId, body PutGroupsGroupIdJSONRequestBody, reqEditors... RequestEditorFn) (*http.Response, error)

// GetLeaveRequests request
    GetLeaveRequests(ctx context.Context, params *GetLeaveRequestsParams, reqEditors... RequestEditorFn) (*http.Response, error)

// ProcessLeaveRequests request
    ProcessLeaveRequests(ctx context.Context, id string, params *ProcessLeaveRequestsParams, reqEditors... RequestEditorFn) (*http.Response, error)

// GetLevels request
    GetLevels(ctx context.Context, params *GetLevelsParams, reqEditors... RequestEditorFn) (*http.Response, error)

// PostMarkAppInstalled request
    PostMarkAppInstalled(ctx context.Context, reqEditors... RequestEditorFn) (*http.Response, error)

// GetMe request
    GetMe(ctx context.Context, reqEditors... RequestEditorFn) (*http.Response, error)

// GetSamlIdpMetadata request
    GetSamlIdpMetadata(ctx context.Context, reqEditors... RequestEditorFn) (*http.Response, error)

// GetTeams request
    GetTeams(ctx context.Context, params *GetTeamsParams, reqEditors... RequestEditorFn) (*http.Response, error)

// GetWorkLocations request
    GetWorkLocations(ctx context.Context, params *GetWorkLocationsParams, reqEditors... RequestEditorFn) (*http.Response, error)


}



func (c *Client) PostAtsCandidatesPushCandidateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewPostAtsCandidatesPushCandidateRequestWithBody(c.Server, contentType, body)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) PostAtsCandidatesPushCandidate(ctx context.Context, body PostAtsCandidatesPushCandidateJSONRequestBody, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewPostAtsCandidatesPushCandidateRequest(c.Server, body)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}

func (c *Client) GetCompanies(ctx context.Context, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewGetCompaniesRequest(c.Server)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) GetCompanyActivity(ctx context.Context, params *GetCompanyActivityParams, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewGetCompanyActivityRequest(c.Server, params)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) GetCustomFields(ctx context.Context, params *GetCustomFieldsParams, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewGetCustomFieldsRequest(c.Server, params)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) GetDepartments(ctx context.Context, params *GetDepartmentsParams, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewGetDepartmentsRequest(c.Server, params)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) GetEmployees(ctx context.Context, params *GetEmployeesParams, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewGetEmployeesRequest(c.Server, params)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) GetEmployeesIncludeTerminated(ctx context.Context, params *GetEmployeesIncludeTerminatedParams, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewGetEmployeesIncludeTerminatedRequest(c.Server, params)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) GetEmployeesEmployeeId(ctx context.Context, employeeId EmployeeId, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewGetEmployeesEmployeeIdRequest(c.Server, employeeId)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) GetGroups(ctx context.Context, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewGetGroupsRequest(c.Server)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) PostGroupsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewPostGroupsRequestWithBody(c.Server, contentType, body)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) PostGroups(ctx context.Context, body PostGroupsJSONRequestBody, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewPostGroupsRequest(c.Server, body)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}

func (c *Client) DeleteGroupsGroupId(ctx context.Context, groupId GroupId, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewDeleteGroupsGroupIdRequest(c.Server, groupId)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) PatchGroupsGroupIdWithBody(ctx context.Context, groupId GroupId, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewPatchGroupsGroupIdRequestWithBody(c.Server, groupId, contentType, body)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) PatchGroupsGroupId(ctx context.Context, groupId GroupId, body PatchGroupsGroupIdJSONRequestBody, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewPatchGroupsGroupIdRequest(c.Server, groupId, body)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}

func (c *Client) PutGroupsGroupIdWithBody(ctx context.Context, groupId GroupId, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewPutGroupsGroupIdRequestWithBody(c.Server, groupId, contentType, body)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) PutGroupsGroupId(ctx context.Context, groupId GroupId, body PutGroupsGroupIdJSONRequestBody, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewPutGroupsGroupIdRequest(c.Server, groupId, body)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}

func (c *Client) GetLeaveRequests(ctx context.Context, params *GetLeaveRequestsParams, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewGetLeaveRequestsRequest(c.Server, params)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) ProcessLeaveRequests(ctx context.Context, id string, params *ProcessLeaveRequestsParams, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewProcessLeaveRequestsRequest(c.Server, id, params)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) GetLevels(ctx context.Context, params *GetLevelsParams, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewGetLevelsRequest(c.Server, params)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) PostMarkAppInstalled(ctx context.Context, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewPostMarkAppInstalledRequest(c.Server)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) GetMe(ctx context.Context, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewGetMeRequest(c.Server)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) GetSamlIdpMetadata(ctx context.Context, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewGetSamlIdpMetadataRequest(c.Server)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) GetTeams(ctx context.Context, params *GetTeamsParams, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewGetTeamsRequest(c.Server, params)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}


func (c *Client) GetWorkLocations(ctx context.Context, params *GetWorkLocationsParams, reqEditors... RequestEditorFn) (*http.Response, error) {
    req, err := NewGetWorkLocationsRequest(c.Server, params)
    if err != nil {
        return nil, err
    }
    req = req.WithContext(ctx)
    if err := c.applyEditors(ctx, req, reqEditors); err != nil {
        return nil, err
    }
    return c.Client.Do(req)
}







// NewPostAtsCandidatesPushCandidateRequest calls the generic PostAtsCandidatesPushCandidate builder with application/json body
func NewPostAtsCandidatesPushCandidateRequest(server string, body PostAtsCandidatesPushCandidateJSONRequestBody) (*http.Request, error) {
    var bodyReader io.Reader
    buf, err := json.Marshal(body)
    if err != nil {
        return nil, err
    }
    bodyReader = bytes.NewReader(buf)
    return NewPostAtsCandidatesPushCandidateRequestWithBody(server, "application/json", bodyReader)
}


// NewPostAtsCandidatesPushCandidateRequestWithBody generates requests for PostAtsCandidatesPushCandidate with any type of body
func NewPostAtsCandidatesPushCandidateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
    var err error

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/ats_candidates/push_candidate")
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    req, err := http.NewRequest("POST", queryURL.String(), body)
    if err != nil {
        return nil, err
    }

    req.Header.Add("Content-Type", contentType)



    return req, nil
}




// NewGetCompaniesRequest generates requests for GetCompanies
func NewGetCompaniesRequest(server string) (*http.Request, error) {
    var err error

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/companies/current")
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    req, err := http.NewRequest("GET", queryURL.String(), nil)
    if err != nil {
        return nil, err
    }

    



    return req, nil
}




// NewGetCompanyActivityRequest generates requests for GetCompanyActivity
func NewGetCompanyActivityRequest(server string, params *GetCompanyActivityParams) (*http.Request, error) {
    var err error

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/company_activity")
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    queryValues := queryURL.Query()

     if params.StartDate != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startDate", runtime.ParamLocationQuery, *params.StartDate); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

     if params.EndDate != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "endDate", runtime.ParamLocationQuery, *params.EndDate); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

     if params.Next != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "next", runtime.ParamLocationQuery, *params.Next); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

     if params.Limit != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

    queryURL.RawQuery = queryValues.Encode()

    req, err := http.NewRequest("GET", queryURL.String(), nil)
    if err != nil {
        return nil, err
    }

    



    return req, nil
}




// NewGetCustomFieldsRequest generates requests for GetCustomFields
func NewGetCustomFieldsRequest(server string, params *GetCustomFieldsParams) (*http.Request, error) {
    var err error

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/custom_fields")
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    queryValues := queryURL.Query()

     if params.Limit != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

     if params.Offset != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

    queryURL.RawQuery = queryValues.Encode()

    req, err := http.NewRequest("GET", queryURL.String(), nil)
    if err != nil {
        return nil, err
    }

    



    return req, nil
}




// NewGetDepartmentsRequest generates requests for GetDepartments
func NewGetDepartmentsRequest(server string, params *GetDepartmentsParams) (*http.Request, error) {
    var err error

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/departments")
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    queryValues := queryURL.Query()

     if params.Limit != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

     if params.Offset != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

    queryURL.RawQuery = queryValues.Encode()

    req, err := http.NewRequest("GET", queryURL.String(), nil)
    if err != nil {
        return nil, err
    }

    



    return req, nil
}




// NewGetEmployeesRequest generates requests for GetEmployees
func NewGetEmployeesRequest(server string, params *GetEmployeesParams) (*http.Request, error) {
    var err error

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/employees")
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    queryValues := queryURL.Query()

     if params.Limit != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

     if params.Offset != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

    queryURL.RawQuery = queryValues.Encode()

    req, err := http.NewRequest("GET", queryURL.String(), nil)
    if err != nil {
        return nil, err
    }

    



    return req, nil
}




// NewGetEmployeesIncludeTerminatedRequest generates requests for GetEmployeesIncludeTerminated
func NewGetEmployeesIncludeTerminatedRequest(server string, params *GetEmployeesIncludeTerminatedParams) (*http.Request, error) {
    var err error

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/employees/include_terminated")
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    queryValues := queryURL.Query()

     if params.Limit != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

     if params.Offset != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

     if params.EIN != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "EIN", runtime.ParamLocationQuery, *params.EIN); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

    queryURL.RawQuery = queryValues.Encode()

    req, err := http.NewRequest("GET", queryURL.String(), nil)
    if err != nil {
        return nil, err
    }

    



    return req, nil
}




// NewGetEmployeesEmployeeIdRequest generates requests for GetEmployeesEmployeeId
func NewGetEmployeesEmployeeIdRequest(server string, employeeId EmployeeId) (*http.Request, error) {
    var err error

    var pathParam0 string
    
    
    
    pathParam0, err = runtime.StyleParamWithLocation("simple", false, "employeeId", runtime.ParamLocationPath, employeeId)
    if err != nil {
        return nil, err
    }
    

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/employees/%s", pathParam0)
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    req, err := http.NewRequest("GET", queryURL.String(), nil)
    if err != nil {
        return nil, err
    }

    



    return req, nil
}




// NewGetGroupsRequest generates requests for GetGroups
func NewGetGroupsRequest(server string) (*http.Request, error) {
    var err error

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/groups")
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    req, err := http.NewRequest("GET", queryURL.String(), nil)
    if err != nil {
        return nil, err
    }

    



    return req, nil
}



// NewPostGroupsRequest calls the generic PostGroups builder with application/json body
func NewPostGroupsRequest(server string, body PostGroupsJSONRequestBody) (*http.Request, error) {
    var bodyReader io.Reader
    buf, err := json.Marshal(body)
    if err != nil {
        return nil, err
    }
    bodyReader = bytes.NewReader(buf)
    return NewPostGroupsRequestWithBody(server, "application/json", bodyReader)
}


// NewPostGroupsRequestWithBody generates requests for PostGroups with any type of body
func NewPostGroupsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
    var err error

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/groups")
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    req, err := http.NewRequest("POST", queryURL.String(), body)
    if err != nil {
        return nil, err
    }

    req.Header.Add("Content-Type", contentType)



    return req, nil
}




// NewDeleteGroupsGroupIdRequest generates requests for DeleteGroupsGroupId
func NewDeleteGroupsGroupIdRequest(server string, groupId GroupId) (*http.Request, error) {
    var err error

    var pathParam0 string
    
    
    
    pathParam0, err = runtime.StyleParamWithLocation("simple", false, "groupId", runtime.ParamLocationPath, groupId)
    if err != nil {
        return nil, err
    }
    

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/groups/%s", pathParam0)
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    req, err := http.NewRequest("DELETE", queryURL.String(), nil)
    if err != nil {
        return nil, err
    }

    



    return req, nil
}



// NewPatchGroupsGroupIdRequest calls the generic PatchGroupsGroupId builder with application/json body
func NewPatchGroupsGroupIdRequest(server string, groupId GroupId, body PatchGroupsGroupIdJSONRequestBody) (*http.Request, error) {
    var bodyReader io.Reader
    buf, err := json.Marshal(body)
    if err != nil {
        return nil, err
    }
    bodyReader = bytes.NewReader(buf)
    return NewPatchGroupsGroupIdRequestWithBody(server, groupId, "application/json", bodyReader)
}


// NewPatchGroupsGroupIdRequestWithBody generates requests for PatchGroupsGroupId with any type of body
func NewPatchGroupsGroupIdRequestWithBody(server string, groupId GroupId, contentType string, body io.Reader) (*http.Request, error) {
    var err error

    var pathParam0 string
    
    
    
    pathParam0, err = runtime.StyleParamWithLocation("simple", false, "groupId", runtime.ParamLocationPath, groupId)
    if err != nil {
        return nil, err
    }
    

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/groups/%s", pathParam0)
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    req, err := http.NewRequest("PATCH", queryURL.String(), body)
    if err != nil {
        return nil, err
    }

    req.Header.Add("Content-Type", contentType)



    return req, nil
}



// NewPutGroupsGroupIdRequest calls the generic PutGroupsGroupId builder with application/json body
func NewPutGroupsGroupIdRequest(server string, groupId GroupId, body PutGroupsGroupIdJSONRequestBody) (*http.Request, error) {
    var bodyReader io.Reader
    buf, err := json.Marshal(body)
    if err != nil {
        return nil, err
    }
    bodyReader = bytes.NewReader(buf)
    return NewPutGroupsGroupIdRequestWithBody(server, groupId, "application/json", bodyReader)
}


// NewPutGroupsGroupIdRequestWithBody generates requests for PutGroupsGroupId with any type of body
func NewPutGroupsGroupIdRequestWithBody(server string, groupId GroupId, contentType string, body io.Reader) (*http.Request, error) {
    var err error

    var pathParam0 string
    
    
    
    pathParam0, err = runtime.StyleParamWithLocation("simple", false, "groupId", runtime.ParamLocationPath, groupId)
    if err != nil {
        return nil, err
    }
    

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/groups/%s", pathParam0)
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    req, err := http.NewRequest("PUT", queryURL.String(), body)
    if err != nil {
        return nil, err
    }

    req.Header.Add("Content-Type", contentType)



    return req, nil
}




// NewGetLeaveRequestsRequest generates requests for GetLeaveRequests
func NewGetLeaveRequestsRequest(server string, params *GetLeaveRequestsParams) (*http.Request, error) {
    var err error

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/leave_requests")
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    queryValues := queryURL.Query()

     if params.Id != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "id", runtime.ParamLocationQuery, *params.Id); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

     if params.Role != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "role", runtime.ParamLocationQuery, *params.Role); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

     if params.RequestedBy != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "requestedBy", runtime.ParamLocationQuery, *params.RequestedBy); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

     if params.Status != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

     if params.StartDate != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "startDate", runtime.ParamLocationQuery, *params.StartDate); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

     if params.EndDate != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "endDate", runtime.ParamLocationQuery, *params.EndDate); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

     if params.LeavePolicy != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "leavePolicy", runtime.ParamLocationQuery, *params.LeavePolicy); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

     if params.ProcessedBy != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "processedBy", runtime.ParamLocationQuery, *params.ProcessedBy); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

     if params.From != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "from", runtime.ParamLocationQuery, *params.From); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

     if params.To != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "to", runtime.ParamLocationQuery, *params.To); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

    queryURL.RawQuery = queryValues.Encode()

    req, err := http.NewRequest("GET", queryURL.String(), nil)
    if err != nil {
        return nil, err
    }

    



    return req, nil
}




// NewProcessLeaveRequestsRequest generates requests for ProcessLeaveRequests
func NewProcessLeaveRequestsRequest(server string, id string, params *ProcessLeaveRequestsParams) (*http.Request, error) {
    var err error

    var pathParam0 string
    
    
    
    pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
    if err != nil {
        return nil, err
    }
    

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/leave_requests/%s/process", pathParam0)
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    queryValues := queryURL.Query()

    
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "action", runtime.ParamLocationQuery, params.Action); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    

    queryURL.RawQuery = queryValues.Encode()

    req, err := http.NewRequest("POST", queryURL.String(), nil)
    if err != nil {
        return nil, err
    }

    



    return req, nil
}




// NewGetLevelsRequest generates requests for GetLevels
func NewGetLevelsRequest(server string, params *GetLevelsParams) (*http.Request, error) {
    var err error

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/levels")
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    queryValues := queryURL.Query()

     if params.Limit != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

     if params.Offset != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

    queryURL.RawQuery = queryValues.Encode()

    req, err := http.NewRequest("GET", queryURL.String(), nil)
    if err != nil {
        return nil, err
    }

    



    return req, nil
}




// NewPostMarkAppInstalledRequest generates requests for PostMarkAppInstalled
func NewPostMarkAppInstalledRequest(server string) (*http.Request, error) {
    var err error

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/mark_app_installed")
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    req, err := http.NewRequest("POST", queryURL.String(), nil)
    if err != nil {
        return nil, err
    }

    



    return req, nil
}




// NewGetMeRequest generates requests for GetMe
func NewGetMeRequest(server string) (*http.Request, error) {
    var err error

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/me")
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    req, err := http.NewRequest("GET", queryURL.String(), nil)
    if err != nil {
        return nil, err
    }

    



    return req, nil
}




// NewGetSamlIdpMetadataRequest generates requests for GetSamlIdpMetadata
func NewGetSamlIdpMetadataRequest(server string) (*http.Request, error) {
    var err error

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/saml/idp_metadata")
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    req, err := http.NewRequest("GET", queryURL.String(), nil)
    if err != nil {
        return nil, err
    }

    



    return req, nil
}




// NewGetTeamsRequest generates requests for GetTeams
func NewGetTeamsRequest(server string, params *GetTeamsParams) (*http.Request, error) {
    var err error

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/teams")
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    queryValues := queryURL.Query()

     if params.Limit != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

     if params.Offset != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

    queryURL.RawQuery = queryValues.Encode()

    req, err := http.NewRequest("GET", queryURL.String(), nil)
    if err != nil {
        return nil, err
    }

    



    return req, nil
}




// NewGetWorkLocationsRequest generates requests for GetWorkLocations
func NewGetWorkLocationsRequest(server string, params *GetWorkLocationsParams) (*http.Request, error) {
    var err error

    serverURL, err := url.Parse(server)
    if err != nil {
        return nil, err
    }

    operationPath := fmt.Sprintf("/work_locations")
    if operationPath[0] == '/' {
        operationPath = "." + operationPath
    }

    queryURL, err := serverURL.Parse(operationPath)
    if err != nil {
        return nil, err
    }


    queryValues := queryURL.Query()

     if params.Limit != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

     if params.Offset != nil { 
    
    
    
    if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
        return nil, err
    } else if parsed, err := url.ParseQuery(queryFrag); err != nil {
       return nil, err
    } else {
       for k, v := range parsed {
           for _, v2 := range v {
               queryValues.Add(k, v2)
           }
       }
    }
    
    }

    queryURL.RawQuery = queryValues.Encode()

    req, err := http.NewRequest("GET", queryURL.String(), nil)
    if err != nil {
        return nil, err
    }

    



    return req, nil
}



func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
    for _, r := range c.RequestEditors {
        if err := r(ctx, req); err != nil {
            return err
        }
    }
    for _, r := range additionalEditors {
        if err := r(ctx, req); err != nil {
            return err
        }
    }
    return nil
}
// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
    ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
    client, err := NewClient(server, opts...)
    if err != nil {
        return nil, err
    }
    return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
// PostAtsCandidatesPushCandidate request with any body
    PostAtsCandidatesPushCandidateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*PostAtsCandidatesPushCandidateResponse, error)

    PostAtsCandidatesPushCandidateWithResponse(ctx context.Context, body PostAtsCandidatesPushCandidateJSONRequestBody, reqEditors... RequestEditorFn) (*PostAtsCandidatesPushCandidateResponse, error)

// GetCompanies request
    GetCompaniesWithResponse(ctx context.Context, reqEditors... RequestEditorFn) (*GetCompaniesResponse, error)

// GetCompanyActivity request
    GetCompanyActivityWithResponse(ctx context.Context, params *GetCompanyActivityParams, reqEditors... RequestEditorFn) (*GetCompanyActivityResponse, error)

// GetCustomFields request
    GetCustomFieldsWithResponse(ctx context.Context, params *GetCustomFieldsParams, reqEditors... RequestEditorFn) (*GetCustomFieldsResponse, error)

// GetDepartments request
    GetDepartmentsWithResponse(ctx context.Context, params *GetDepartmentsParams, reqEditors... RequestEditorFn) (*GetDepartmentsResponse, error)

// GetEmployees request
    GetEmployeesWithResponse(ctx context.Context, params *GetEmployeesParams, reqEditors... RequestEditorFn) (*GetEmployeesResponse, error)

// GetEmployeesIncludeTerminated request
    GetEmployeesIncludeTerminatedWithResponse(ctx context.Context, params *GetEmployeesIncludeTerminatedParams, reqEditors... RequestEditorFn) (*GetEmployeesIncludeTerminatedResponse, error)

// GetEmployeesEmployeeId request
    GetEmployeesEmployeeIdWithResponse(ctx context.Context, employeeId EmployeeId, reqEditors... RequestEditorFn) (*GetEmployeesEmployeeIdResponse, error)

// GetGroups request
    GetGroupsWithResponse(ctx context.Context, reqEditors... RequestEditorFn) (*GetGroupsResponse, error)

// PostGroups request with any body
    PostGroupsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*PostGroupsResponse, error)

    PostGroupsWithResponse(ctx context.Context, body PostGroupsJSONRequestBody, reqEditors... RequestEditorFn) (*PostGroupsResponse, error)

// DeleteGroupsGroupId request
    DeleteGroupsGroupIdWithResponse(ctx context.Context, groupId GroupId, reqEditors... RequestEditorFn) (*DeleteGroupsGroupIdResponse, error)

// PatchGroupsGroupId request with any body
    PatchGroupsGroupIdWithBodyWithResponse(ctx context.Context, groupId GroupId, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*PatchGroupsGroupIdResponse, error)

    PatchGroupsGroupIdWithResponse(ctx context.Context, groupId GroupId, body PatchGroupsGroupIdJSONRequestBody, reqEditors... RequestEditorFn) (*PatchGroupsGroupIdResponse, error)

// PutGroupsGroupId request with any body
    PutGroupsGroupIdWithBodyWithResponse(ctx context.Context, groupId GroupId, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*PutGroupsGroupIdResponse, error)

    PutGroupsGroupIdWithResponse(ctx context.Context, groupId GroupId, body PutGroupsGroupIdJSONRequestBody, reqEditors... RequestEditorFn) (*PutGroupsGroupIdResponse, error)

// GetLeaveRequests request
    GetLeaveRequestsWithResponse(ctx context.Context, params *GetLeaveRequestsParams, reqEditors... RequestEditorFn) (*GetLeaveRequestsResponse, error)

// ProcessLeaveRequests request
    ProcessLeaveRequestsWithResponse(ctx context.Context, id string, params *ProcessLeaveRequestsParams, reqEditors... RequestEditorFn) (*ProcessLeaveRequestsResponse, error)

// GetLevels request
    GetLevelsWithResponse(ctx context.Context, params *GetLevelsParams, reqEditors... RequestEditorFn) (*GetLevelsResponse, error)

// PostMarkAppInstalled request
    PostMarkAppInstalledWithResponse(ctx context.Context, reqEditors... RequestEditorFn) (*PostMarkAppInstalledResponse, error)

// GetMe request
    GetMeWithResponse(ctx context.Context, reqEditors... RequestEditorFn) (*GetMeResponse, error)

// GetSamlIdpMetadata request
    GetSamlIdpMetadataWithResponse(ctx context.Context, reqEditors... RequestEditorFn) (*GetSamlIdpMetadataResponse, error)

// GetTeams request
    GetTeamsWithResponse(ctx context.Context, params *GetTeamsParams, reqEditors... RequestEditorFn) (*GetTeamsResponse, error)

// GetWorkLocations request
    GetWorkLocationsWithResponse(ctx context.Context, params *GetWorkLocationsParams, reqEditors... RequestEditorFn) (*GetWorkLocationsResponse, error)


}


type PostAtsCandidatesPushCandidateResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON200 *Candidate
}

// Status returns HTTPResponse.Status
func (r PostAtsCandidatesPushCandidateResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostAtsCandidatesPushCandidateResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}

type GetCompaniesResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON200 *Company
}

// Status returns HTTPResponse.Status
func (r GetCompaniesResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCompaniesResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}

type GetCompanyActivityResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON200 *struct {
    Data *struct {
    Events *[]Event`json:"events"`
    Next *string`json:"next,omitempty"`
}`json:"data"`
    Error *string`json:"error"`
}
}

// Status returns HTTPResponse.Status
func (r GetCompanyActivityResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCompanyActivityResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}

type GetCustomFieldsResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON200 *[]CustomFields
}

// Status returns HTTPResponse.Status
func (r GetCustomFieldsResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCustomFieldsResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}

type GetDepartmentsResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON200 *[]Department
}

// Status returns HTTPResponse.Status
func (r GetDepartmentsResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetDepartmentsResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}

type GetEmployeesResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON200 *[]Employee
}

// Status returns HTTPResponse.Status
func (r GetEmployeesResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEmployeesResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}

type GetEmployeesIncludeTerminatedResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON200 *[]Employee
}

// Status returns HTTPResponse.Status
func (r GetEmployeesIncludeTerminatedResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEmployeesIncludeTerminatedResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}

type GetEmployeesEmployeeIdResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON200 *Employee
}

// Status returns HTTPResponse.Status
func (r GetEmployeesEmployeeIdResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetEmployeesEmployeeIdResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}

type GetGroupsResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON200 *[]Group
}

// Status returns HTTPResponse.Status
func (r GetGroupsResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGroupsResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}

type PostGroupsResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON201 *Group
}

// Status returns HTTPResponse.Status
func (r PostGroupsResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostGroupsResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}

type DeleteGroupsGroupIdResponse struct {
    Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r DeleteGroupsGroupIdResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteGroupsGroupIdResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}

type PatchGroupsGroupIdResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON200 *Group
}

// Status returns HTTPResponse.Status
func (r PatchGroupsGroupIdResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PatchGroupsGroupIdResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}

type PutGroupsGroupIdResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON200 *Group
}

// Status returns HTTPResponse.Status
func (r PutGroupsGroupIdResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutGroupsGroupIdResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}

type GetLeaveRequestsResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON200 *[]LeaveRequest
}

// Status returns HTTPResponse.Status
func (r GetLeaveRequestsResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLeaveRequestsResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}

type ProcessLeaveRequestsResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON200 *LeaveRequest
}

// Status returns HTTPResponse.Status
func (r ProcessLeaveRequestsResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ProcessLeaveRequestsResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}

type GetLevelsResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON200 *[]Level
}

// Status returns HTTPResponse.Status
func (r GetLevelsResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetLevelsResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}

type PostMarkAppInstalledResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON200 *struct {
    Ok bool`json:"ok"`
}
}

// Status returns HTTPResponse.Status
func (r PostMarkAppInstalledResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostMarkAppInstalledResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}

type GetMeResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON200 *AuthenticatedUserMe
}

// Status returns HTTPResponse.Status
func (r GetMeResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMeResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}

type GetSamlIdpMetadataResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    XML200 *string
}

// Status returns HTTPResponse.Status
func (r GetSamlIdpMetadataResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSamlIdpMetadataResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}

type GetTeamsResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON200 *[]Team
}

// Status returns HTTPResponse.Status
func (r GetTeamsResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTeamsResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}

type GetWorkLocationsResponse struct {
    Body         []byte
	HTTPResponse *http.Response
    JSON200 *[]WorkLocation
}

// Status returns HTTPResponse.Status
func (r GetWorkLocationsResponse) Status() string {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.Status
    }
    return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetWorkLocationsResponse) StatusCode() int {
    if r.HTTPResponse != nil {
        return r.HTTPResponse.StatusCode
    }
    return 0
}






// PostAtsCandidatesPushCandidateWithBodyWithResponse request with arbitrary body returning *PostAtsCandidatesPushCandidateResponse
func (c *ClientWithResponses) PostAtsCandidatesPushCandidateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*PostAtsCandidatesPushCandidateResponse, error){
    rsp, err := c.PostAtsCandidatesPushCandidateWithBody(ctx, contentType, body, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParsePostAtsCandidatesPushCandidateResponse(rsp)
}


func (c *ClientWithResponses) PostAtsCandidatesPushCandidateWithResponse(ctx context.Context, body PostAtsCandidatesPushCandidateJSONRequestBody, reqEditors... RequestEditorFn) (*PostAtsCandidatesPushCandidateResponse, error) {
    rsp, err := c.PostAtsCandidatesPushCandidate(ctx, body, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParsePostAtsCandidatesPushCandidateResponse(rsp)
}





// GetCompaniesWithResponse request returning *GetCompaniesResponse
func (c *ClientWithResponses) GetCompaniesWithResponse(ctx context.Context, reqEditors... RequestEditorFn) (*GetCompaniesResponse, error){
    rsp, err := c.GetCompanies(ctx, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseGetCompaniesResponse(rsp)
}






// GetCompanyActivityWithResponse request returning *GetCompanyActivityResponse
func (c *ClientWithResponses) GetCompanyActivityWithResponse(ctx context.Context, params *GetCompanyActivityParams, reqEditors... RequestEditorFn) (*GetCompanyActivityResponse, error){
    rsp, err := c.GetCompanyActivity(ctx, params, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseGetCompanyActivityResponse(rsp)
}






// GetCustomFieldsWithResponse request returning *GetCustomFieldsResponse
func (c *ClientWithResponses) GetCustomFieldsWithResponse(ctx context.Context, params *GetCustomFieldsParams, reqEditors... RequestEditorFn) (*GetCustomFieldsResponse, error){
    rsp, err := c.GetCustomFields(ctx, params, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseGetCustomFieldsResponse(rsp)
}






// GetDepartmentsWithResponse request returning *GetDepartmentsResponse
func (c *ClientWithResponses) GetDepartmentsWithResponse(ctx context.Context, params *GetDepartmentsParams, reqEditors... RequestEditorFn) (*GetDepartmentsResponse, error){
    rsp, err := c.GetDepartments(ctx, params, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseGetDepartmentsResponse(rsp)
}






// GetEmployeesWithResponse request returning *GetEmployeesResponse
func (c *ClientWithResponses) GetEmployeesWithResponse(ctx context.Context, params *GetEmployeesParams, reqEditors... RequestEditorFn) (*GetEmployeesResponse, error){
    rsp, err := c.GetEmployees(ctx, params, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseGetEmployeesResponse(rsp)
}






// GetEmployeesIncludeTerminatedWithResponse request returning *GetEmployeesIncludeTerminatedResponse
func (c *ClientWithResponses) GetEmployeesIncludeTerminatedWithResponse(ctx context.Context, params *GetEmployeesIncludeTerminatedParams, reqEditors... RequestEditorFn) (*GetEmployeesIncludeTerminatedResponse, error){
    rsp, err := c.GetEmployeesIncludeTerminated(ctx, params, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseGetEmployeesIncludeTerminatedResponse(rsp)
}






// GetEmployeesEmployeeIdWithResponse request returning *GetEmployeesEmployeeIdResponse
func (c *ClientWithResponses) GetEmployeesEmployeeIdWithResponse(ctx context.Context, employeeId EmployeeId, reqEditors... RequestEditorFn) (*GetEmployeesEmployeeIdResponse, error){
    rsp, err := c.GetEmployeesEmployeeId(ctx, employeeId, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseGetEmployeesEmployeeIdResponse(rsp)
}






// GetGroupsWithResponse request returning *GetGroupsResponse
func (c *ClientWithResponses) GetGroupsWithResponse(ctx context.Context, reqEditors... RequestEditorFn) (*GetGroupsResponse, error){
    rsp, err := c.GetGroups(ctx, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseGetGroupsResponse(rsp)
}






// PostGroupsWithBodyWithResponse request with arbitrary body returning *PostGroupsResponse
func (c *ClientWithResponses) PostGroupsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*PostGroupsResponse, error){
    rsp, err := c.PostGroupsWithBody(ctx, contentType, body, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParsePostGroupsResponse(rsp)
}


func (c *ClientWithResponses) PostGroupsWithResponse(ctx context.Context, body PostGroupsJSONRequestBody, reqEditors... RequestEditorFn) (*PostGroupsResponse, error) {
    rsp, err := c.PostGroups(ctx, body, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParsePostGroupsResponse(rsp)
}





// DeleteGroupsGroupIdWithResponse request returning *DeleteGroupsGroupIdResponse
func (c *ClientWithResponses) DeleteGroupsGroupIdWithResponse(ctx context.Context, groupId GroupId, reqEditors... RequestEditorFn) (*DeleteGroupsGroupIdResponse, error){
    rsp, err := c.DeleteGroupsGroupId(ctx, groupId, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseDeleteGroupsGroupIdResponse(rsp)
}






// PatchGroupsGroupIdWithBodyWithResponse request with arbitrary body returning *PatchGroupsGroupIdResponse
func (c *ClientWithResponses) PatchGroupsGroupIdWithBodyWithResponse(ctx context.Context, groupId GroupId, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*PatchGroupsGroupIdResponse, error){
    rsp, err := c.PatchGroupsGroupIdWithBody(ctx, groupId, contentType, body, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParsePatchGroupsGroupIdResponse(rsp)
}


func (c *ClientWithResponses) PatchGroupsGroupIdWithResponse(ctx context.Context, groupId GroupId, body PatchGroupsGroupIdJSONRequestBody, reqEditors... RequestEditorFn) (*PatchGroupsGroupIdResponse, error) {
    rsp, err := c.PatchGroupsGroupId(ctx, groupId, body, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParsePatchGroupsGroupIdResponse(rsp)
}





// PutGroupsGroupIdWithBodyWithResponse request with arbitrary body returning *PutGroupsGroupIdResponse
func (c *ClientWithResponses) PutGroupsGroupIdWithBodyWithResponse(ctx context.Context, groupId GroupId, contentType string, body io.Reader, reqEditors... RequestEditorFn) (*PutGroupsGroupIdResponse, error){
    rsp, err := c.PutGroupsGroupIdWithBody(ctx, groupId, contentType, body, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParsePutGroupsGroupIdResponse(rsp)
}


func (c *ClientWithResponses) PutGroupsGroupIdWithResponse(ctx context.Context, groupId GroupId, body PutGroupsGroupIdJSONRequestBody, reqEditors... RequestEditorFn) (*PutGroupsGroupIdResponse, error) {
    rsp, err := c.PutGroupsGroupId(ctx, groupId, body, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParsePutGroupsGroupIdResponse(rsp)
}





// GetLeaveRequestsWithResponse request returning *GetLeaveRequestsResponse
func (c *ClientWithResponses) GetLeaveRequestsWithResponse(ctx context.Context, params *GetLeaveRequestsParams, reqEditors... RequestEditorFn) (*GetLeaveRequestsResponse, error){
    rsp, err := c.GetLeaveRequests(ctx, params, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseGetLeaveRequestsResponse(rsp)
}






// ProcessLeaveRequestsWithResponse request returning *ProcessLeaveRequestsResponse
func (c *ClientWithResponses) ProcessLeaveRequestsWithResponse(ctx context.Context, id string, params *ProcessLeaveRequestsParams, reqEditors... RequestEditorFn) (*ProcessLeaveRequestsResponse, error){
    rsp, err := c.ProcessLeaveRequests(ctx, id, params, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseProcessLeaveRequestsResponse(rsp)
}






// GetLevelsWithResponse request returning *GetLevelsResponse
func (c *ClientWithResponses) GetLevelsWithResponse(ctx context.Context, params *GetLevelsParams, reqEditors... RequestEditorFn) (*GetLevelsResponse, error){
    rsp, err := c.GetLevels(ctx, params, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseGetLevelsResponse(rsp)
}






// PostMarkAppInstalledWithResponse request returning *PostMarkAppInstalledResponse
func (c *ClientWithResponses) PostMarkAppInstalledWithResponse(ctx context.Context, reqEditors... RequestEditorFn) (*PostMarkAppInstalledResponse, error){
    rsp, err := c.PostMarkAppInstalled(ctx, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParsePostMarkAppInstalledResponse(rsp)
}






// GetMeWithResponse request returning *GetMeResponse
func (c *ClientWithResponses) GetMeWithResponse(ctx context.Context, reqEditors... RequestEditorFn) (*GetMeResponse, error){
    rsp, err := c.GetMe(ctx, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseGetMeResponse(rsp)
}






// GetSamlIdpMetadataWithResponse request returning *GetSamlIdpMetadataResponse
func (c *ClientWithResponses) GetSamlIdpMetadataWithResponse(ctx context.Context, reqEditors... RequestEditorFn) (*GetSamlIdpMetadataResponse, error){
    rsp, err := c.GetSamlIdpMetadata(ctx, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseGetSamlIdpMetadataResponse(rsp)
}






// GetTeamsWithResponse request returning *GetTeamsResponse
func (c *ClientWithResponses) GetTeamsWithResponse(ctx context.Context, params *GetTeamsParams, reqEditors... RequestEditorFn) (*GetTeamsResponse, error){
    rsp, err := c.GetTeams(ctx, params, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseGetTeamsResponse(rsp)
}






// GetWorkLocationsWithResponse request returning *GetWorkLocationsResponse
func (c *ClientWithResponses) GetWorkLocationsWithResponse(ctx context.Context, params *GetWorkLocationsParams, reqEditors... RequestEditorFn) (*GetWorkLocationsResponse, error){
    rsp, err := c.GetWorkLocations(ctx, params, reqEditors...)
    if err != nil {
        return nil, err
    }
    return ParseGetWorkLocationsResponse(rsp)
}








// ParsePostAtsCandidatesPushCandidateResponse parses an HTTP response from a PostAtsCandidatesPushCandidateWithResponse call
func ParsePostAtsCandidatesPushCandidateResponse(rsp *http.Response) (*PostAtsCandidatesPushCandidateResponse, error) {
    bodyBytes, err := ioutil.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &PostAtsCandidatesPushCandidateResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
var dest Candidate
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON200 = &dest

}


    return response, nil
}


// ParseGetCompaniesResponse parses an HTTP response from a GetCompaniesWithResponse call
func ParseGetCompaniesResponse(rsp *http.Response) (*GetCompaniesResponse, error) {
    bodyBytes, err := ioutil.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &GetCompaniesResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
var dest Company
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON200 = &dest

}


    return response, nil
}


// ParseGetCompanyActivityResponse parses an HTTP response from a GetCompanyActivityWithResponse call
func ParseGetCompanyActivityResponse(rsp *http.Response) (*GetCompanyActivityResponse, error) {
    bodyBytes, err := ioutil.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &GetCompanyActivityResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
var dest struct {
    Data *struct {
    Events *[]Event`json:"events"`
    Next *string`json:"next,omitempty"`
}`json:"data"`
    Error *string`json:"error"`
}
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON200 = &dest

}


    return response, nil
}


// ParseGetCustomFieldsResponse parses an HTTP response from a GetCustomFieldsWithResponse call
func ParseGetCustomFieldsResponse(rsp *http.Response) (*GetCustomFieldsResponse, error) {
    bodyBytes, err := ioutil.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &GetCustomFieldsResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
var dest []CustomFields
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON200 = &dest

}


    return response, nil
}


// ParseGetDepartmentsResponse parses an HTTP response from a GetDepartmentsWithResponse call
func ParseGetDepartmentsResponse(rsp *http.Response) (*GetDepartmentsResponse, error) {
    bodyBytes, err := ioutil.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &GetDepartmentsResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
var dest []Department
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON200 = &dest

}


    return response, nil
}


// ParseGetEmployeesResponse parses an HTTP response from a GetEmployeesWithResponse call
func ParseGetEmployeesResponse(rsp *http.Response) (*GetEmployeesResponse, error) {
    bodyBytes, err := ioutil.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &GetEmployeesResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
var dest []Employee
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON200 = &dest

}


    return response, nil
}


// ParseGetEmployeesIncludeTerminatedResponse parses an HTTP response from a GetEmployeesIncludeTerminatedWithResponse call
func ParseGetEmployeesIncludeTerminatedResponse(rsp *http.Response) (*GetEmployeesIncludeTerminatedResponse, error) {
    bodyBytes, err := ioutil.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &GetEmployeesIncludeTerminatedResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
var dest []Employee
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON200 = &dest

}


    return response, nil
}


// ParseGetEmployeesEmployeeIdResponse parses an HTTP response from a GetEmployeesEmployeeIdWithResponse call
func ParseGetEmployeesEmployeeIdResponse(rsp *http.Response) (*GetEmployeesEmployeeIdResponse, error) {
    bodyBytes, err := ioutil.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &GetEmployeesEmployeeIdResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
var dest Employee
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON200 = &dest

}


    return response, nil
}


// ParseGetGroupsResponse parses an HTTP response from a GetGroupsWithResponse call
func ParseGetGroupsResponse(rsp *http.Response) (*GetGroupsResponse, error) {
    bodyBytes, err := ioutil.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &GetGroupsResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
var dest []Group
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON200 = &dest

}


    return response, nil
}


// ParsePostGroupsResponse parses an HTTP response from a PostGroupsWithResponse call
func ParsePostGroupsResponse(rsp *http.Response) (*PostGroupsResponse, error) {
    bodyBytes, err := ioutil.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &PostGroupsResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
var dest Group
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON201 = &dest

}


    return response, nil
}


// ParseDeleteGroupsGroupIdResponse parses an HTTP response from a DeleteGroupsGroupIdWithResponse call
func ParseDeleteGroupsGroupIdResponse(rsp *http.Response) (*DeleteGroupsGroupIdResponse, error) {
    bodyBytes, err := ioutil.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &DeleteGroupsGroupIdResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}

    

    return response, nil
}


// ParsePatchGroupsGroupIdResponse parses an HTTP response from a PatchGroupsGroupIdWithResponse call
func ParsePatchGroupsGroupIdResponse(rsp *http.Response) (*PatchGroupsGroupIdResponse, error) {
    bodyBytes, err := ioutil.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &PatchGroupsGroupIdResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
var dest Group
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON200 = &dest

}


    return response, nil
}


// ParsePutGroupsGroupIdResponse parses an HTTP response from a PutGroupsGroupIdWithResponse call
func ParsePutGroupsGroupIdResponse(rsp *http.Response) (*PutGroupsGroupIdResponse, error) {
    bodyBytes, err := ioutil.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &PutGroupsGroupIdResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
var dest Group
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON200 = &dest

}


    return response, nil
}


// ParseGetLeaveRequestsResponse parses an HTTP response from a GetLeaveRequestsWithResponse call
func ParseGetLeaveRequestsResponse(rsp *http.Response) (*GetLeaveRequestsResponse, error) {
    bodyBytes, err := ioutil.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &GetLeaveRequestsResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
var dest []LeaveRequest
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON200 = &dest

}


    return response, nil
}


// ParseProcessLeaveRequestsResponse parses an HTTP response from a ProcessLeaveRequestsWithResponse call
func ParseProcessLeaveRequestsResponse(rsp *http.Response) (*ProcessLeaveRequestsResponse, error) {
    bodyBytes, err := ioutil.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &ProcessLeaveRequestsResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
var dest LeaveRequest
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON200 = &dest

}


    return response, nil
}


// ParseGetLevelsResponse parses an HTTP response from a GetLevelsWithResponse call
func ParseGetLevelsResponse(rsp *http.Response) (*GetLevelsResponse, error) {
    bodyBytes, err := ioutil.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &GetLevelsResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
var dest []Level
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON200 = &dest

}


    return response, nil
}


// ParsePostMarkAppInstalledResponse parses an HTTP response from a PostMarkAppInstalledWithResponse call
func ParsePostMarkAppInstalledResponse(rsp *http.Response) (*PostMarkAppInstalledResponse, error) {
    bodyBytes, err := ioutil.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &PostMarkAppInstalledResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
var dest struct {
    Ok bool`json:"ok"`
}
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON200 = &dest

}


    return response, nil
}


// ParseGetMeResponse parses an HTTP response from a GetMeWithResponse call
func ParseGetMeResponse(rsp *http.Response) (*GetMeResponse, error) {
    bodyBytes, err := ioutil.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &GetMeResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
var dest AuthenticatedUserMe
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON200 = &dest

}


    return response, nil
}


// ParseGetSamlIdpMetadataResponse parses an HTTP response from a GetSamlIdpMetadataWithResponse call
func ParseGetSamlIdpMetadataResponse(rsp *http.Response) (*GetSamlIdpMetadataResponse, error) {
    bodyBytes, err := ioutil.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &GetSamlIdpMetadataResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "xml") && rsp.StatusCode == 200:
var dest string
if err := xml.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.XML200 = &dest

}


    return response, nil
}


// ParseGetTeamsResponse parses an HTTP response from a GetTeamsWithResponse call
func ParseGetTeamsResponse(rsp *http.Response) (*GetTeamsResponse, error) {
    bodyBytes, err := ioutil.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &GetTeamsResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
var dest []Team
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON200 = &dest

}


    return response, nil
}


// ParseGetWorkLocationsResponse parses an HTTP response from a GetWorkLocationsWithResponse call
func ParseGetWorkLocationsResponse(rsp *http.Response) (*GetWorkLocationsResponse, error) {
    bodyBytes, err := ioutil.ReadAll(rsp.Body)
    defer func() { _ = rsp.Body.Close() }()
    if err != nil {
        return nil, err
    }

    response := &GetWorkLocationsResponse{
Body: bodyBytes,
HTTPResponse: rsp,
}

    switch {
case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
var dest []WorkLocation
if err := json.Unmarshal(bodyBytes, &dest); err != nil { 
 return nil, err 
}
response.JSON200 = &dest

}


    return response, nil
}


// ServerInterface represents all server handlers.
type ServerInterface interface {
// POST New Candidate
// (POST /ats_candidates/push_candidate)
PostAtsCandidatesPushCandidate(w http.ResponseWriter, r *http.Request)
// GET Current Company
// (GET /companies/current)
GetCompanies(w http.ResponseWriter, r *http.Request)
// GET Company Activity
// (GET /company_activity)
GetCompanyActivity(w http.ResponseWriter, r *http.Request, params GetCompanyActivityParams)
// GET Custom Fields
// (GET /custom_fields)
GetCustomFields(w http.ResponseWriter, r *http.Request, params GetCustomFieldsParams)
// GET Departments
// (GET /departments)
GetDepartments(w http.ResponseWriter, r *http.Request, params GetDepartmentsParams)
// GET Employees
// (GET /employees)
GetEmployees(w http.ResponseWriter, r *http.Request, params GetEmployeesParams)
// GET Employees (Including Terminated)
// (GET /employees/include_terminated)
GetEmployeesIncludeTerminated(w http.ResponseWriter, r *http.Request, params GetEmployeesIncludeTerminatedParams)
// GET Employee
// (GET /employees/{employeeId})
GetEmployeesEmployeeId(w http.ResponseWriter, r *http.Request, employeeId EmployeeId)
// GET Groups
// (GET /groups)
GetGroups(w http.ResponseWriter, r *http.Request)
// POST Groups
// (POST /groups)
PostGroups(w http.ResponseWriter, r *http.Request)
// DELETE Group
// (DELETE /groups/{groupId})
DeleteGroupsGroupId(w http.ResponseWriter, r *http.Request, groupId GroupId)
// PATCH Group
// (PATCH /groups/{groupId})
PatchGroupsGroupId(w http.ResponseWriter, r *http.Request, groupId GroupId)
// PUT Group
// (PUT /groups/{groupId})
PutGroupsGroupId(w http.ResponseWriter, r *http.Request, groupId GroupId)
// GET Leave Requests
// (GET /leave_requests)
GetLeaveRequests(w http.ResponseWriter, r *http.Request, params GetLeaveRequestsParams)
// POST Process Leave Request
// (POST /leave_requests/{id}/process)
ProcessLeaveRequests(w http.ResponseWriter, r *http.Request, id string, params ProcessLeaveRequestsParams)
// GET Levels
// (GET /levels)
GetLevels(w http.ResponseWriter, r *http.Request, params GetLevelsParams)
// Mark App Installed
// (POST /mark_app_installed)
PostMarkAppInstalled(w http.ResponseWriter, r *http.Request)
// GET Current User
// (GET /me)
GetMe(w http.ResponseWriter, r *http.Request)
// GET SAML Metadata
// (GET /saml/idp_metadata)
GetSamlIdpMetadata(w http.ResponseWriter, r *http.Request)
// GET Teams
// (GET /teams)
GetTeams(w http.ResponseWriter, r *http.Request, params GetTeamsParams)
// GET Work Locations
// (GET /work_locations)
GetWorkLocations(w http.ResponseWriter, r *http.Request, params GetWorkLocationsParams)

}

// ServerInterfaceWrapper converts contexts to parameters.
type ServerInterfaceWrapper struct {
    Handler ServerInterface
    HandlerMiddlewares []MiddlewareFunc
    ErrorHandlerFunc func(w http.ResponseWriter, r *http.Request, err error)
}

type MiddlewareFunc func(http.HandlerFunc) http.HandlerFunc



// PostAtsCandidatesPushCandidate operation middleware
func (siw *ServerInterfaceWrapper) PostAtsCandidatesPushCandidate(w http.ResponseWriter, r *http.Request) {
  ctx := r.Context()
  

  


  ctx = context.WithValue(ctx, AuthorizationCodeScopes, []string{"ats:candidates"})


  

  var handler = func(w http.ResponseWriter, r *http.Request) {
    siw.Handler.PostAtsCandidatesPushCandidate(w, r)
}

  for _, middleware := range siw.HandlerMiddlewares {
    handler = middleware(handler)
  }

  handler(w, r.WithContext(ctx))
}


// GetCompanies operation middleware
func (siw *ServerInterfaceWrapper) GetCompanies(w http.ResponseWriter, r *http.Request) {
  ctx := r.Context()
  

  


  ctx = context.WithValue(ctx, Bearer ApiKeyScopes, []string{""})

  ctx = context.WithValue(ctx, AuthorizationCodeScopes, []string{"company","company:*"})


  

  var handler = func(w http.ResponseWriter, r *http.Request) {
    siw.Handler.GetCompanies(w, r)
}

  for _, middleware := range siw.HandlerMiddlewares {
    handler = middleware(handler)
  }

  handler(w, r.WithContext(ctx))
}


// GetCompanyActivity operation middleware
func (siw *ServerInterfaceWrapper) GetCompanyActivity(w http.ResponseWriter, r *http.Request) {
  ctx := r.Context()
  
  var err error
  

  


  ctx = context.WithValue(ctx, Bearer ApiKeyScopes, []string{""})

  ctx = context.WithValue(ctx, AuthorizationCodeScopes, []string{"company","company:activity"})


  
    // Parameter object where we will unmarshal all parameters from the context
    var params GetCompanyActivityParams

    // ------------- Optional query parameter "startDate" -------------
      if paramValue := r.URL.Query().Get("startDate"); paramValue != "" {

      

      
      }
      
      err = runtime.BindQueryParameter("form", true, false, "startDate", r.URL.Query(), &params.StartDate)
      if err != nil {
        siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "startDate", Err: err})
        return
      }
      
  // ------------- Optional query parameter "endDate" -------------
      if paramValue := r.URL.Query().Get("endDate"); paramValue != "" {

      

      
      }
      
      err = runtime.BindQueryParameter("form", true, false, "endDate", r.URL.Query(), &params.EndDate)
      if err != nil {
        siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "endDate", Err: err})
        return
      }
      
  // ------------- Optional query parameter "next" -------------
      if paramValue := r.URL.Query().Get("next"); paramValue != "" {

      

      
      }
      
      err = runtime.BindQueryParameter("form", true, false, "next", r.URL.Query(), &params.Next)
      if err != nil {
        siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "next", Err: err})
        return
      }
      
  // ------------- Optional query parameter "limit" -------------
      if paramValue := r.URL.Query().Get("limit"); paramValue != "" {

      

      
      }
      
      err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
      if err != nil {
        siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
        return
      }
      
  

    

    
  

  var handler = func(w http.ResponseWriter, r *http.Request) {
    siw.Handler.GetCompanyActivity(w, r, params)
}

  for _, middleware := range siw.HandlerMiddlewares {
    handler = middleware(handler)
  }

  handler(w, r.WithContext(ctx))
}


// GetCustomFields operation middleware
func (siw *ServerInterfaceWrapper) GetCustomFields(w http.ResponseWriter, r *http.Request) {
  ctx := r.Context()
  
  var err error
  

  


  ctx = context.WithValue(ctx, Bearer ApiKeyScopes, []string{""})

  ctx = context.WithValue(ctx, AuthorizationCodeScopes, []string{"company","company:customFields"})


  
    // Parameter object where we will unmarshal all parameters from the context
    var params GetCustomFieldsParams

    // ------------- Optional query parameter "limit" -------------
      if paramValue := r.URL.Query().Get("limit"); paramValue != "" {

      

      
      }
      
      err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
      if err != nil {
        siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
        return
      }
      
  // ------------- Optional query parameter "offset" -------------
      if paramValue := r.URL.Query().Get("offset"); paramValue != "" {

      

      
      }
      
      err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
      if err != nil {
        siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
        return
      }
      
  

    

    
  

  var handler = func(w http.ResponseWriter, r *http.Request) {
    siw.Handler.GetCustomFields(w, r, params)
}

  for _, middleware := range siw.HandlerMiddlewares {
    handler = middleware(handler)
  }

  handler(w, r.WithContext(ctx))
}


// GetDepartments operation middleware
func (siw *ServerInterfaceWrapper) GetDepartments(w http.ResponseWriter, r *http.Request) {
  ctx := r.Context()
  
  var err error
  

  


  ctx = context.WithValue(ctx, AuthorizationCodeScopes, []string{"company","company:departments"})

  ctx = context.WithValue(ctx, Bearer ApiKeyScopes, []string{""})


  
    // Parameter object where we will unmarshal all parameters from the context
    var params GetDepartmentsParams

    // ------------- Optional query parameter "limit" -------------
      if paramValue := r.URL.Query().Get("limit"); paramValue != "" {

      

      
      }
      
      err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
      if err != nil {
        siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
        return
      }
      
  // ------------- Optional query parameter "offset" -------------
      if paramValue := r.URL.Query().Get("offset"); paramValue != "" {

      

      
      }
      
      err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
      if err != nil {
        siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
        return
      }
      
  

    

    
  

  var handler = func(w http.ResponseWriter, r *http.Request) {
    siw.Handler.GetDepartments(w, r, params)
}

  for _, middleware := range siw.HandlerMiddlewares {
    handler = middleware(handler)
  }

  handler(w, r.WithContext(ctx))
}


// GetEmployees operation middleware
func (siw *ServerInterfaceWrapper) GetEmployees(w http.ResponseWriter, r *http.Request) {
  ctx := r.Context()
  
  var err error
  

  


  ctx = context.WithValue(ctx, Bearer ApiKeyScopes, []string{""})

  ctx = context.WithValue(ctx, AuthorizationCodeScopes, []string{"employee"})


  
    // Parameter object where we will unmarshal all parameters from the context
    var params GetEmployeesParams

    // ------------- Optional query parameter "limit" -------------
      if paramValue := r.URL.Query().Get("limit"); paramValue != "" {

      

      
      }
      
      err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
      if err != nil {
        siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
        return
      }
      
  // ------------- Optional query parameter "offset" -------------
      if paramValue := r.URL.Query().Get("offset"); paramValue != "" {

      

      
      }
      
      err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
      if err != nil {
        siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
        return
      }
      
  

    

    
  

  var handler = func(w http.ResponseWriter, r *http.Request) {
    siw.Handler.GetEmployees(w, r, params)
}

  for _, middleware := range siw.HandlerMiddlewares {
    handler = middleware(handler)
  }

  handler(w, r.WithContext(ctx))
}


// GetEmployeesIncludeTerminated operation middleware
func (siw *ServerInterfaceWrapper) GetEmployeesIncludeTerminated(w http.ResponseWriter, r *http.Request) {
  ctx := r.Context()
  
  var err error
  

  


  ctx = context.WithValue(ctx, Bearer ApiKeyScopes, []string{""})

  ctx = context.WithValue(ctx, AuthorizationCodeScopes, []string{"employee"})


  
    // Parameter object where we will unmarshal all parameters from the context
    var params GetEmployeesIncludeTerminatedParams

    // ------------- Optional query parameter "limit" -------------
      if paramValue := r.URL.Query().Get("limit"); paramValue != "" {

      

      
      }
      
      err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
      if err != nil {
        siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
        return
      }
      
  // ------------- Optional query parameter "offset" -------------
      if paramValue := r.URL.Query().Get("offset"); paramValue != "" {

      

      
      }
      
      err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
      if err != nil {
        siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
        return
      }
      
  // ------------- Optional query parameter "EIN" -------------
      if paramValue := r.URL.Query().Get("EIN"); paramValue != "" {

      

      
      }
      
      err = runtime.BindQueryParameter("form", true, false, "EIN", r.URL.Query(), &params.EIN)
      if err != nil {
        siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "EIN", Err: err})
        return
      }
      
  

    

    
  

  var handler = func(w http.ResponseWriter, r *http.Request) {
    siw.Handler.GetEmployeesIncludeTerminated(w, r, params)
}

  for _, middleware := range siw.HandlerMiddlewares {
    handler = middleware(handler)
  }

  handler(w, r.WithContext(ctx))
}


// GetEmployeesEmployeeId operation middleware
func (siw *ServerInterfaceWrapper) GetEmployeesEmployeeId(w http.ResponseWriter, r *http.Request) {
  ctx := r.Context()
  
  var err error
  

  // ------------- Path parameter "employeeId" -------------
  var employeeId EmployeeId

  
  
  
  err = runtime.BindStyledParameter("simple",false, "employeeId", chi.URLParam(r, "employeeId"), &employeeId)
  if err != nil {
    siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "employeeId", Err: err})
    return
  }
  

  


  ctx = context.WithValue(ctx, Bearer ApiKeyScopes, []string{""})

  ctx = context.WithValue(ctx, AuthorizationCodeScopes, []string{"employee"})


  

  var handler = func(w http.ResponseWriter, r *http.Request) {
    siw.Handler.GetEmployeesEmployeeId(w, r, employeeId)
}

  for _, middleware := range siw.HandlerMiddlewares {
    handler = middleware(handler)
  }

  handler(w, r.WithContext(ctx))
}


// GetGroups operation middleware
func (siw *ServerInterfaceWrapper) GetGroups(w http.ResponseWriter, r *http.Request) {
  ctx := r.Context()
  

  


  ctx = context.WithValue(ctx, AuthorizationCodeScopes, []string{"group_members:read","groups:read"})


  

  var handler = func(w http.ResponseWriter, r *http.Request) {
    siw.Handler.GetGroups(w, r)
}

  for _, middleware := range siw.HandlerMiddlewares {
    handler = middleware(handler)
  }

  handler(w, r.WithContext(ctx))
}


// PostGroups operation middleware
func (siw *ServerInterfaceWrapper) PostGroups(w http.ResponseWriter, r *http.Request) {
  ctx := r.Context()
  

  


  ctx = context.WithValue(ctx, AuthorizationCodeScopes, []string{"groups:write","group_members:write"})


  

  var handler = func(w http.ResponseWriter, r *http.Request) {
    siw.Handler.PostGroups(w, r)
}

  for _, middleware := range siw.HandlerMiddlewares {
    handler = middleware(handler)
  }

  handler(w, r.WithContext(ctx))
}


// DeleteGroupsGroupId operation middleware
func (siw *ServerInterfaceWrapper) DeleteGroupsGroupId(w http.ResponseWriter, r *http.Request) {
  ctx := r.Context()
  
  var err error
  

  // ------------- Path parameter "groupId" -------------
  var groupId GroupId

  
  
  
  err = runtime.BindStyledParameter("simple",false, "groupId", chi.URLParam(r, "groupId"), &groupId)
  if err != nil {
    siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "groupId", Err: err})
    return
  }
  

  


  ctx = context.WithValue(ctx, AuthorizationCodeScopes, []string{"groups:write"})


  

  var handler = func(w http.ResponseWriter, r *http.Request) {
    siw.Handler.DeleteGroupsGroupId(w, r, groupId)
}

  for _, middleware := range siw.HandlerMiddlewares {
    handler = middleware(handler)
  }

  handler(w, r.WithContext(ctx))
}


// PatchGroupsGroupId operation middleware
func (siw *ServerInterfaceWrapper) PatchGroupsGroupId(w http.ResponseWriter, r *http.Request) {
  ctx := r.Context()
  
  var err error
  

  // ------------- Path parameter "groupId" -------------
  var groupId GroupId

  
  
  
  err = runtime.BindStyledParameter("simple",false, "groupId", chi.URLParam(r, "groupId"), &groupId)
  if err != nil {
    siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "groupId", Err: err})
    return
  }
  

  


  ctx = context.WithValue(ctx, AuthorizationCodeScopes, []string{"group_members:write","groups:write"})


  

  var handler = func(w http.ResponseWriter, r *http.Request) {
    siw.Handler.PatchGroupsGroupId(w, r, groupId)
}

  for _, middleware := range siw.HandlerMiddlewares {
    handler = middleware(handler)
  }

  handler(w, r.WithContext(ctx))
}


// PutGroupsGroupId operation middleware
func (siw *ServerInterfaceWrapper) PutGroupsGroupId(w http.ResponseWriter, r *http.Request) {
  ctx := r.Context()
  
  var err error
  

  // ------------- Path parameter "groupId" -------------
  var groupId GroupId

  
  
  
  err = runtime.BindStyledParameter("simple",false, "groupId", chi.URLParam(r, "groupId"), &groupId)
  if err != nil {
    siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "groupId", Err: err})
    return
  }
  

  


  ctx = context.WithValue(ctx, AuthorizationCodeScopes, []string{"group_members:write","groups:write"})


  

  var handler = func(w http.ResponseWriter, r *http.Request) {
    siw.Handler.PutGroupsGroupId(w, r, groupId)
}

  for _, middleware := range siw.HandlerMiddlewares {
    handler = middleware(handler)
  }

  handler(w, r.WithContext(ctx))
}


// GetLeaveRequests operation middleware
func (siw *ServerInterfaceWrapper) GetLeaveRequests(w http.ResponseWriter, r *http.Request) {
  ctx := r.Context()
  
  var err error
  

  


  ctx = context.WithValue(ctx, Bearer ApiKeyScopes, []string{""})

  ctx = context.WithValue(ctx, AuthorizationCodeScopes, []string{"company","company:leave_requests"})


  
    // Parameter object where we will unmarshal all parameters from the context
    var params GetLeaveRequestsParams

    // ------------- Optional query parameter "id" -------------
      if paramValue := r.URL.Query().Get("id"); paramValue != "" {

      

      
      }
      
      err = runtime.BindQueryParameter("form", true, false, "id", r.URL.Query(), &params.Id)
      if err != nil {
        siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
        return
      }
      
  // ------------- Optional query parameter "role" -------------
      if paramValue := r.URL.Query().Get("role"); paramValue != "" {

      

      
      }
      
      err = runtime.BindQueryParameter("form", true, false, "role", r.URL.Query(), &params.Role)
      if err != nil {
        siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "role", Err: err})
        return
      }
      
  // ------------- Optional query parameter "requestedBy" -------------
      if paramValue := r.URL.Query().Get("requestedBy"); paramValue != "" {

      

      
      }
      
      err = runtime.BindQueryParameter("form", true, false, "requestedBy", r.URL.Query(), &params.RequestedBy)
      if err != nil {
        siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "requestedBy", Err: err})
        return
      }
      
  // ------------- Optional query parameter "status" -------------
      if paramValue := r.URL.Query().Get("status"); paramValue != "" {

      

      
      }
      
      err = runtime.BindQueryParameter("form", true, false, "status", r.URL.Query(), &params.Status)
      if err != nil {
        siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "status", Err: err})
        return
      }
      
  // ------------- Optional query parameter "startDate" -------------
      if paramValue := r.URL.Query().Get("startDate"); paramValue != "" {

      

      
      }
      
      err = runtime.BindQueryParameter("form", true, false, "startDate", r.URL.Query(), &params.StartDate)
      if err != nil {
        siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "startDate", Err: err})
        return
      }
      
  // ------------- Optional query parameter "endDate" -------------
      if paramValue := r.URL.Query().Get("endDate"); paramValue != "" {

      

      
      }
      
      err = runtime.BindQueryParameter("form", true, false, "endDate", r.URL.Query(), &params.EndDate)
      if err != nil {
        siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "endDate", Err: err})
        return
      }
      
  // ------------- Optional query parameter "leavePolicy" -------------
      if paramValue := r.URL.Query().Get("leavePolicy"); paramValue != "" {

      

      
      }
      
      err = runtime.BindQueryParameter("form", true, false, "leavePolicy", r.URL.Query(), &params.LeavePolicy)
      if err != nil {
        siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "leavePolicy", Err: err})
        return
      }
      
  // ------------- Optional query parameter "processedBy" -------------
      if paramValue := r.URL.Query().Get("processedBy"); paramValue != "" {

      

      
      }
      
      err = runtime.BindQueryParameter("form", true, false, "processedBy", r.URL.Query(), &params.ProcessedBy)
      if err != nil {
        siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "processedBy", Err: err})
        return
      }
      
  // ------------- Optional query parameter "from" -------------
      if paramValue := r.URL.Query().Get("from"); paramValue != "" {

      

      
      }
      
      err = runtime.BindQueryParameter("form", true, false, "from", r.URL.Query(), &params.From)
      if err != nil {
        siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "from", Err: err})
        return
      }
      
  // ------------- Optional query parameter "to" -------------
      if paramValue := r.URL.Query().Get("to"); paramValue != "" {

      

      
      }
      
      err = runtime.BindQueryParameter("form", true, false, "to", r.URL.Query(), &params.To)
      if err != nil {
        siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "to", Err: err})
        return
      }
      
  

    

    
  

  var handler = func(w http.ResponseWriter, r *http.Request) {
    siw.Handler.GetLeaveRequests(w, r, params)
}

  for _, middleware := range siw.HandlerMiddlewares {
    handler = middleware(handler)
  }

  handler(w, r.WithContext(ctx))
}


// ProcessLeaveRequests operation middleware
func (siw *ServerInterfaceWrapper) ProcessLeaveRequests(w http.ResponseWriter, r *http.Request) {
  ctx := r.Context()
  
  var err error
  

  // ------------- Path parameter "id" -------------
  var id string

  
  
  
  err = runtime.BindStyledParameter("simple",false, "id", chi.URLParam(r, "id"), &id)
  if err != nil {
    siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "id", Err: err})
    return
  }
  

  


  ctx = context.WithValue(ctx, Bearer ApiKeyScopes, []string{""})

  ctx = context.WithValue(ctx, AuthorizationCodeScopes, []string{"company:leave_requests"})


  
    // Parameter object where we will unmarshal all parameters from the context
    var params ProcessLeaveRequestsParams

    // ------------- Required query parameter "action" -------------
      if paramValue := r.URL.Query().Get("action"); paramValue != "" {

      

      
      } else {
          siw.ErrorHandlerFunc(w, r, &RequiredParamError{ParamName: "action"})
          return
      }
      
      err = runtime.BindQueryParameter("form", true, true, "action", r.URL.Query(), &params.Action)
      if err != nil {
        siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "action", Err: err})
        return
      }
      
  

    

    
  

  var handler = func(w http.ResponseWriter, r *http.Request) {
    siw.Handler.ProcessLeaveRequests(w, r, id, params)
}

  for _, middleware := range siw.HandlerMiddlewares {
    handler = middleware(handler)
  }

  handler(w, r.WithContext(ctx))
}


// GetLevels operation middleware
func (siw *ServerInterfaceWrapper) GetLevels(w http.ResponseWriter, r *http.Request) {
  ctx := r.Context()
  
  var err error
  

  


  ctx = context.WithValue(ctx, Bearer ApiKeyScopes, []string{""})

  ctx = context.WithValue(ctx, AuthorizationCodeScopes, []string{"company","company:levels"})


  
    // Parameter object where we will unmarshal all parameters from the context
    var params GetLevelsParams

    // ------------- Optional query parameter "limit" -------------
      if paramValue := r.URL.Query().Get("limit"); paramValue != "" {

      

      
      }
      
      err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
      if err != nil {
        siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
        return
      }
      
  // ------------- Optional query parameter "offset" -------------
      if paramValue := r.URL.Query().Get("offset"); paramValue != "" {

      

      
      }
      
      err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
      if err != nil {
        siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
        return
      }
      
  

    

    
  

  var handler = func(w http.ResponseWriter, r *http.Request) {
    siw.Handler.GetLevels(w, r, params)
}

  for _, middleware := range siw.HandlerMiddlewares {
    handler = middleware(handler)
  }

  handler(w, r.WithContext(ctx))
}


// PostMarkAppInstalled operation middleware
func (siw *ServerInterfaceWrapper) PostMarkAppInstalled(w http.ResponseWriter, r *http.Request) {
  ctx := r.Context()
  

  


  ctx = context.WithValue(ctx, AuthorizationCodeScopes, []string{""})


  

  var handler = func(w http.ResponseWriter, r *http.Request) {
    siw.Handler.PostMarkAppInstalled(w, r)
}

  for _, middleware := range siw.HandlerMiddlewares {
    handler = middleware(handler)
  }

  handler(w, r.WithContext(ctx))
}


// GetMe operation middleware
func (siw *ServerInterfaceWrapper) GetMe(w http.ResponseWriter, r *http.Request) {
  ctx := r.Context()
  

  


  ctx = context.WithValue(ctx, Bearer ApiKeyScopes, []string{""})

  ctx = context.WithValue(ctx, AuthorizationCodeScopes, []string{""})


  

  var handler = func(w http.ResponseWriter, r *http.Request) {
    siw.Handler.GetMe(w, r)
}

  for _, middleware := range siw.HandlerMiddlewares {
    handler = middleware(handler)
  }

  handler(w, r.WithContext(ctx))
}


// GetSamlIdpMetadata operation middleware
func (siw *ServerInterfaceWrapper) GetSamlIdpMetadata(w http.ResponseWriter, r *http.Request) {
  ctx := r.Context()
  

  


  ctx = context.WithValue(ctx, AuthorizationCodeScopes, []string{"saml:idp_metadata"})


  

  var handler = func(w http.ResponseWriter, r *http.Request) {
    siw.Handler.GetSamlIdpMetadata(w, r)
}

  for _, middleware := range siw.HandlerMiddlewares {
    handler = middleware(handler)
  }

  handler(w, r.WithContext(ctx))
}


// GetTeams operation middleware
func (siw *ServerInterfaceWrapper) GetTeams(w http.ResponseWriter, r *http.Request) {
  ctx := r.Context()
  
  var err error
  

  


  ctx = context.WithValue(ctx, Bearer ApiKeyScopes, []string{""})

  ctx = context.WithValue(ctx, AuthorizationCodeScopes, []string{"company","company:teams"})


  
    // Parameter object where we will unmarshal all parameters from the context
    var params GetTeamsParams

    // ------------- Optional query parameter "limit" -------------
      if paramValue := r.URL.Query().Get("limit"); paramValue != "" {

      

      
      }
      
      err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
      if err != nil {
        siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
        return
      }
      
  // ------------- Optional query parameter "offset" -------------
      if paramValue := r.URL.Query().Get("offset"); paramValue != "" {

      

      
      }
      
      err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
      if err != nil {
        siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
        return
      }
      
  

    

    
  

  var handler = func(w http.ResponseWriter, r *http.Request) {
    siw.Handler.GetTeams(w, r, params)
}

  for _, middleware := range siw.HandlerMiddlewares {
    handler = middleware(handler)
  }

  handler(w, r.WithContext(ctx))
}


// GetWorkLocations operation middleware
func (siw *ServerInterfaceWrapper) GetWorkLocations(w http.ResponseWriter, r *http.Request) {
  ctx := r.Context()
  
  var err error
  

  


  ctx = context.WithValue(ctx, AuthorizationCodeScopes, []string{"company","company:workLocations"})

  ctx = context.WithValue(ctx, Bearer ApiKeyScopes, []string{""})


  
    // Parameter object where we will unmarshal all parameters from the context
    var params GetWorkLocationsParams

    // ------------- Optional query parameter "limit" -------------
      if paramValue := r.URL.Query().Get("limit"); paramValue != "" {

      

      
      }
      
      err = runtime.BindQueryParameter("form", true, false, "limit", r.URL.Query(), &params.Limit)
      if err != nil {
        siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "limit", Err: err})
        return
      }
      
  // ------------- Optional query parameter "offset" -------------
      if paramValue := r.URL.Query().Get("offset"); paramValue != "" {

      

      
      }
      
      err = runtime.BindQueryParameter("form", true, false, "offset", r.URL.Query(), &params.Offset)
      if err != nil {
        siw.ErrorHandlerFunc(w, r, &InvalidParamFormatError{ParamName: "offset", Err: err})
        return
      }
      
  

    

    
  

  var handler = func(w http.ResponseWriter, r *http.Request) {
    siw.Handler.GetWorkLocations(w, r, params)
}

  for _, middleware := range siw.HandlerMiddlewares {
    handler = middleware(handler)
  }

  handler(w, r.WithContext(ctx))
}


type UnescapedCookieParamError struct {
    ParamName string
  	Err error
}

func (e *UnescapedCookieParamError) Error() string {
    return fmt.Sprintf("error unescaping cookie parameter '%s'", e.ParamName)
}

func (e *UnescapedCookieParamError) Unwrap() error {
    return e.Err
}

type UnmarshalingParamError struct {
    ParamName string
    Err error
}

func (e *UnmarshalingParamError) Error() string {
    return fmt.Sprintf("Error unmarshaling parameter %s as JSON: %s", e.ParamName, e.Err.Error())
}

func (e *UnmarshalingParamError) Unwrap() error {
    return e.Err
}

type RequiredParamError struct {
    ParamName string
}

func (e *RequiredParamError) Error() string {
    return fmt.Sprintf("Query argument %s is required, but not found", e.ParamName)
}

type RequiredHeaderError struct {
    ParamName string
    Err error
}

func (e *RequiredHeaderError) Error() string {
    return fmt.Sprintf("Header parameter %s is required, but not found", e.ParamName)
}

func (e *RequiredHeaderError) Unwrap() error {
    return e.Err
}

type InvalidParamFormatError struct {
    ParamName string
	  Err error
}

func (e *InvalidParamFormatError) Error() string {
    return fmt.Sprintf("Invalid format for parameter %s: %s", e.ParamName, e.Err.Error())
}

func (e *InvalidParamFormatError) Unwrap() error {
    return e.Err
}

type TooManyValuesForParamError struct {
    ParamName string
    Count int
}

func (e *TooManyValuesForParamError) Error() string {
    return fmt.Sprintf("Expected one value for %s, got %d", e.ParamName, e.Count)
}

// Handler creates http.Handler with routing matching OpenAPI spec.
func Handler(si ServerInterface) http.Handler {
  return HandlerWithOptions(si, ChiServerOptions{})
}

type ChiServerOptions struct {
    BaseURL string
    BaseRouter chi.Router
    Middlewares []MiddlewareFunc
    ErrorHandlerFunc   func(w http.ResponseWriter, r *http.Request, err error)
}

// HandlerFromMux creates http.Handler with routing matching OpenAPI spec based on the provided mux.
func HandlerFromMux(si ServerInterface, r chi.Router) http.Handler {
    return HandlerWithOptions(si, ChiServerOptions {
        BaseRouter: r,
    })
}

func HandlerFromMuxWithBaseURL(si ServerInterface, r chi.Router, baseURL string) http.Handler {
    return HandlerWithOptions(si, ChiServerOptions {
        BaseURL: baseURL,
        BaseRouter: r,
    })
}

// HandlerWithOptions creates http.Handler with additional options
func HandlerWithOptions(si ServerInterface, options ChiServerOptions) http.Handler {
r := options.BaseRouter

if r == nil {
r = chi.NewRouter()
}
if options.ErrorHandlerFunc == nil {
    options.ErrorHandlerFunc = func(w http.ResponseWriter, r *http.Request, err error) {
        http.Error(w, err.Error(), http.StatusBadRequest)
    }
}
wrapper := ServerInterfaceWrapper{
Handler: si,
HandlerMiddlewares: options.Middlewares,
ErrorHandlerFunc: options.ErrorHandlerFunc,
}

r.Group(func(r chi.Router) {
r.Post(options.BaseURL+"/ats_candidates/push_candidate", wrapper.PostAtsCandidatesPushCandidate)
})
r.Group(func(r chi.Router) {
r.Get(options.BaseURL+"/companies/current", wrapper.GetCompanies)
})
r.Group(func(r chi.Router) {
r.Get(options.BaseURL+"/company_activity", wrapper.GetCompanyActivity)
})
r.Group(func(r chi.Router) {
r.Get(options.BaseURL+"/custom_fields", wrapper.GetCustomFields)
})
r.Group(func(r chi.Router) {
r.Get(options.BaseURL+"/departments", wrapper.GetDepartments)
})
r.Group(func(r chi.Router) {
r.Get(options.BaseURL+"/employees", wrapper.GetEmployees)
})
r.Group(func(r chi.Router) {
r.Get(options.BaseURL+"/employees/include_terminated", wrapper.GetEmployeesIncludeTerminated)
})
r.Group(func(r chi.Router) {
r.Get(options.BaseURL+"/employees/{employeeId}", wrapper.GetEmployeesEmployeeId)
})
r.Group(func(r chi.Router) {
r.Get(options.BaseURL+"/groups", wrapper.GetGroups)
})
r.Group(func(r chi.Router) {
r.Post(options.BaseURL+"/groups", wrapper.PostGroups)
})
r.Group(func(r chi.Router) {
r.Delete(options.BaseURL+"/groups/{groupId}", wrapper.DeleteGroupsGroupId)
})
r.Group(func(r chi.Router) {
r.Patch(options.BaseURL+"/groups/{groupId}", wrapper.PatchGroupsGroupId)
})
r.Group(func(r chi.Router) {
r.Put(options.BaseURL+"/groups/{groupId}", wrapper.PutGroupsGroupId)
})
r.Group(func(r chi.Router) {
r.Get(options.BaseURL+"/leave_requests", wrapper.GetLeaveRequests)
})
r.Group(func(r chi.Router) {
r.Post(options.BaseURL+"/leave_requests/{id}/process", wrapper.ProcessLeaveRequests)
})
r.Group(func(r chi.Router) {
r.Get(options.BaseURL+"/levels", wrapper.GetLevels)
})
r.Group(func(r chi.Router) {
r.Post(options.BaseURL+"/mark_app_installed", wrapper.PostMarkAppInstalled)
})
r.Group(func(r chi.Router) {
r.Get(options.BaseURL+"/me", wrapper.GetMe)
})
r.Group(func(r chi.Router) {
r.Get(options.BaseURL+"/saml/idp_metadata", wrapper.GetSamlIdpMetadata)
})
r.Group(func(r chi.Router) {
r.Get(options.BaseURL+"/teams", wrapper.GetTeams)
})
r.Group(func(r chi.Router) {
r.Get(options.BaseURL+"/work_locations", wrapper.GetWorkLocations)
})

return r
}
// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

    "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",
    "OpdPwdR3nvoTe8bb3pFzmw0uexeL6Vtv1b84X03rr+dvayPPaYzc/sX5o0NGi2m39/vg3BGQ7OXytdtw",
    "G1fkZeC8OGd3BL49Jlf+8HE6secXy+pq0LWbg4mzHHweLAcfR/DSbq8Gk/5y0HVWw679efDZXg0vaDKr",
    "O5Kf176zuiP5ee07qzuSn1c6q845+WwPz+cPnxYP+PJ0WT23X/cubPv6/ONrezl/99CZv+vZd2Q1vGi2",
    "f7meNa6c5hs2d7r4lyjsvmOd5mcUfv48HUbd1jX8HU/d23jyrtUK6sP+1dv667d1+/h1fTi7I6gDFw9v",
    "HxpovnpXXfothJ3Pjvc5HJy0TuJJcLO6PJq3yMvBzHd7F69nrfhpcXT9ZjD9bdU9Qe0hvSOnzkP7oWaT",
    "6HO9bUetk9qTT35beb/4A+e2uzrxJpcXD6/aR3Myue3Yy55tT7IzuyP2aybmNn9tT6/br47G4wc06J46",
    "N48nbv3NW/eiPvkYL94M5zN83mp+ItdOe/h7+3o5e9eahm71lzvy6uKl/bJGlr9557/HL9vXl9VXZBJC",
    "Mnr7YvDbZOI8XNy6TRothvbognqdut+8tn3c6od0OphG3os7suhOP03qL9/efHKvJ4+1y16r/vQaVV20",
    "aLz9fHEVnDD49Kl3/Nv8lL35/fTVS7sD66H9669a7z0q5bhceZ5Tj0o4+2hNPORlx1jE3nEpdU1UvnBw",
    "joUdfYs8mspa7OzFZHJzMEIyE/edBXSo1SZVGAY4zQzPGD1iwYHKYofcUkV5Xfh/vwncXI8n/6ODPyra",
    "QPKzuzYsxJvKxBu6T7535kExb0S05NemD6PTfMNNgI27z6+Cb7Tf1M3t6KoYvFwEsL4KJf3djq7WkLwJ",
    "iR350MiNSI0B1LMjk1Ug9lB9HMw3usSPyMCc2sqNHnMVjMOaD7GnHm+VZUXPmpi6x1oDozAz+HW1JXeC",
    "lhWsTdlghFVBGwTSFOeYgN8GVwWJTL/eu2r9LZoCO09mOIah5/JQFCkDj3oYbq+MLaLN2oVNkZVkIqD/",
    "L7hiOZ3m7jWM0D7D+so2347AujQrNtxWzXEadbeVQum70gqyBUIrN46TFMILGLpLGG65oYF6Jk5jdjJt",
    "t9EshXADVyH1vO9xQyOemv4TLmgkPRewgybFDdczSxo+3HtpGvwdsjxqlsg+uFWYhr2IP95m8u7/dfME",
    "/amvBRS/D7A3xWYe+f6xebiyzy3smomLDxCY1FJGyvlRZV/CSW4GNl4ZoPCx2FXjJnn/yqpYce7Rsg3P",
    "F1kFfqGQuFP6tAaHye8b9EYB70OCgcTXPIMJI91bJiDf+N45BFrmGV+7h6BZrT2Yn1JPZOOj3kmNT/lb",
    "FKNIvbxifCm/uTMqvTwEI5G0M9N1FwUhcmTo4Ycv/y8AAP//suXG0OK+AAA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
    zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
    if err != nil {
        return nil, fmt.Errorf("error base64 decoding spec: %s", err)
    }
    zr, err := gzip.NewReader(bytes.NewReader(zipped))
    if err != nil {
        return nil, fmt.Errorf("error decompressing spec: %s", err)
    }
    var buf bytes.Buffer
    _, err = buf.ReadFrom(zr)
    if err != nil {
        return nil, fmt.Errorf("error decompressing spec: %s", err)
    }

    return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
    var res = make(map[string]func() ([]byte, error))
    if len(pathToFile) > 0 {
        res[pathToFile] = rawSpec
    }
    
    
    return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
    var resolvePath = PathToRawSpec("")

    loader := openapi3.NewLoader()
    loader.IsExternalRefsAllowed = true
    loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
        var pathToFile = url.String()
        pathToFile = path.Clean(pathToFile)
        getSpec, ok := resolvePath[pathToFile]
        if !ok {
            err1 := fmt.Errorf("path not found: %s", pathToFile)
            return nil, err1
        }
        return getSpec()
    }
    var specData []byte
    specData, err = rawSpec()
    if err != nil {
        return
    }
    swagger, err = loader.LoadFromData(specData)
    if err != nil {
        return
    }
    return
}

