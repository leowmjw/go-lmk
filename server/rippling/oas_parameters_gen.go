// Code generated by ogen, DO NOT EDIT.

package rippling

import (
	"net/http"
	"time"

	"github.com/go-faster/errors"

	"github.com/ogen-go/ogen/conv"
	"github.com/ogen-go/ogen/uri"
)

type CustomFieldsGetParams struct {
	// Sets a limit on the returned values.
	Limit OptInt
	// Offsets the returned values.
	Offset OptInt
}

func decodeCustomFieldsGetParams(args [0]string, r *http.Request) (params CustomFieldsGetParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: offset.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "offset",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotOffsetVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotOffsetVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Offset.SetTo(paramsDotOffsetVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: offset: parse")
			}
		}
	}
	return params, nil
}

type DeleteGroupsGroupIdParams struct {
	// Unique identifier for the group within Rippling.
	GroupId int
}

func decodeDeleteGroupsGroupIdParams(args [1]string, r *http.Request) (params DeleteGroupsGroupIdParams, _ error) {
	// Decode path: groupId.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "groupId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.GroupId = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: groupId: not specified")
		}
	}
	return params, nil
}

type GetCompanyActivityParams struct {
	// Timestamp to list activity after (inclusive). This should be less than 90 days from now. Defaults
	// to 90 days.
	StartDate OptDate
	// Timestamp to list activity before (inclusive).
	EndDate OptDate
	// Specifies the pagination cursor to the next page.
	Next OptString
	// Specifies the number of results to page (maximum: 1000) (default: 1000).
	Limit OptString
}

func decodeGetCompanyActivityParams(args [0]string, r *http.Request) (params GetCompanyActivityParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: startDate.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "startDate",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotStartDateVal time.Time
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToTime(val)
					if err != nil {
						return err
					}

					paramsDotStartDateVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.StartDate.SetTo(paramsDotStartDateVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: startDate: parse")
			}
		}
	}
	// Decode query: endDate.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "endDate",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotEndDateVal time.Time
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToTime(val)
					if err != nil {
						return err
					}

					paramsDotEndDateVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.EndDate.SetTo(paramsDotEndDateVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: endDate: parse")
			}
		}
	}
	// Decode query: next.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "next",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotNextVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotNextVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Next.SetTo(paramsDotNextVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: next: parse")
			}
		}
	}
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	return params, nil
}

type GetDepartmentsParams struct {
	// Sets a limit on the returned values.
	Limit OptInt
	// Offsets the returned values.
	Offset OptInt
}

func decodeGetDepartmentsParams(args [0]string, r *http.Request) (params GetDepartmentsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: offset.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "offset",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotOffsetVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotOffsetVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Offset.SetTo(paramsDotOffsetVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: offset: parse")
			}
		}
	}
	return params, nil
}

type GetEmployeesParams struct {
	// Sets a limit on the returned values.
	Limit OptInt
	// Offsets the returned values.
	Offset OptInt
}

func decodeGetEmployeesParams(args [0]string, r *http.Request) (params GetEmployeesParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: offset.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "offset",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotOffsetVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotOffsetVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Offset.SetTo(paramsDotOffsetVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: offset: parse")
			}
		}
	}
	return params, nil
}

type GetEmployeesEmployeeIdParams struct {
	// Unique identifier for the employee within Rippling.
	EmployeeId int
}

func decodeGetEmployeesEmployeeIdParams(args [1]string, r *http.Request) (params GetEmployeesEmployeeIdParams, _ error) {
	// Decode path: employeeId.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "employeeId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.EmployeeId = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: employeeId: not specified")
		}
	}
	return params, nil
}

type GetEmployeesIncludeTerminatedParams struct {
	// Sets a limit on the returned values.
	Limit OptInt
	// Offsets the returned values.
	Offset OptInt
	// Employer identification number, also known as the Federal Emplower Identification Number or the
	// Federal Tax Identification Number.
	EIN OptInt
}

func decodeGetEmployeesIncludeTerminatedParams(args [0]string, r *http.Request) (params GetEmployeesIncludeTerminatedParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: offset.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "offset",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotOffsetVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotOffsetVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Offset.SetTo(paramsDotOffsetVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: offset: parse")
			}
		}
	}
	// Decode query: EIN.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "EIN",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotEINVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotEINVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.EIN.SetTo(paramsDotEINVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: EIN: parse")
			}
		}
	}
	return params, nil
}

type GetLeaveRequestsParams struct {
	ID          OptString
	Role        OptString
	RequestedBy OptString
	Status      OptString
	// Start date of leave.
	StartDate OptString
	// End date of leave.
	EndDate     OptString
	LeavePolicy OptString
	ProcessedBy OptString
	// Filter to capture whether the leave request overlaps with a date range.
	From OptString
	// Filter to capture whether the leave request overlaps with a date range.
	To OptString
}

func decodeGetLeaveRequestsParams(args [0]string, r *http.Request) (params GetLeaveRequestsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: id.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "id",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotIDVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotIDVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ID.SetTo(paramsDotIDVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: id: parse")
			}
		}
	}
	// Decode query: role.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "role",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotRoleVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotRoleVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Role.SetTo(paramsDotRoleVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: role: parse")
			}
		}
	}
	// Decode query: requestedBy.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "requestedBy",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotRequestedByVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotRequestedByVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.RequestedBy.SetTo(paramsDotRequestedByVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: requestedBy: parse")
			}
		}
	}
	// Decode query: status.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "status",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotStatusVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotStatusVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Status.SetTo(paramsDotStatusVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: status: parse")
			}
		}
	}
	// Decode query: startDate.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "startDate",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotStartDateVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotStartDateVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.StartDate.SetTo(paramsDotStartDateVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: startDate: parse")
			}
		}
	}
	// Decode query: endDate.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "endDate",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotEndDateVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotEndDateVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.EndDate.SetTo(paramsDotEndDateVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: endDate: parse")
			}
		}
	}
	// Decode query: leavePolicy.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "leavePolicy",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLeavePolicyVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotLeavePolicyVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.LeavePolicy.SetTo(paramsDotLeavePolicyVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: leavePolicy: parse")
			}
		}
	}
	// Decode query: processedBy.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "processedBy",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotProcessedByVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotProcessedByVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.ProcessedBy.SetTo(paramsDotProcessedByVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: processedBy: parse")
			}
		}
	}
	// Decode query: from.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "from",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotFromVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotFromVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.From.SetTo(paramsDotFromVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: from: parse")
			}
		}
	}
	// Decode query: to.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "to",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotToVal string
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToString(val)
					if err != nil {
						return err
					}

					paramsDotToVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.To.SetTo(paramsDotToVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: to: parse")
			}
		}
	}
	return params, nil
}

type GetLevelsParams struct {
	// Sets a limit on the returned values.
	Limit OptInt
	// Offsets the returned values.
	Offset OptInt
}

func decodeGetLevelsParams(args [0]string, r *http.Request) (params GetLevelsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: offset.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "offset",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotOffsetVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotOffsetVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Offset.SetTo(paramsDotOffsetVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: offset: parse")
			}
		}
	}
	return params, nil
}

type GetTeamsParams struct {
	// Sets a limit on the returned values.
	Limit OptInt
	// Offsets the returned values.
	Offset OptInt
}

func decodeGetTeamsParams(args [0]string, r *http.Request) (params GetTeamsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: offset.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "offset",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotOffsetVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotOffsetVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Offset.SetTo(paramsDotOffsetVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: offset: parse")
			}
		}
	}
	return params, nil
}

type GetWorkLocationsParams struct {
	// Sets a limit on the returned values.
	Limit OptInt
	// Offsets the returned values.
	Offset OptInt
}

func decodeGetWorkLocationsParams(args [0]string, r *http.Request) (params GetWorkLocationsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: limit.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "limit",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotLimitVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotLimitVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Limit.SetTo(paramsDotLimitVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: limit: parse")
			}
		}
	}
	// Decode query: offset.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "offset",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				var paramsDotOffsetVal int
				if err := func() error {
					val, err := d.DecodeValue()
					if err != nil {
						return err
					}

					c, err := conv.ToInt(val)
					if err != nil {
						return err
					}

					paramsDotOffsetVal = c
					return nil
				}(); err != nil {
					return err
				}
				params.Offset.SetTo(paramsDotOffsetVal)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: offset: parse")
			}
		}
	}
	return params, nil
}

type PatchGroupsGroupIdParams struct {
	// Unique identifier for the group within Rippling.
	GroupId int
}

func decodePatchGroupsGroupIdParams(args [1]string, r *http.Request) (params PatchGroupsGroupIdParams, _ error) {
	// Decode path: groupId.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "groupId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.GroupId = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: groupId: not specified")
		}
	}
	return params, nil
}

type ProcessLeaveRequestsParams struct {
	// The action to be taken on the leave request. Can be either approved or declined.
	Action ProcessLeaveRequestsAction
	// Unique identifier of the leave request being processed.
	ID string
}

func decodeProcessLeaveRequestsParams(args [1]string, r *http.Request) (params ProcessLeaveRequestsParams, _ error) {
	q := uri.NewQueryDecoder(r.URL.Query())
	// Decode query: action.
	{
		cfg := uri.QueryParameterDecodingConfig{
			Name:    "action",
			Style:   uri.QueryStyleForm,
			Explode: true,
		}

		if err := q.HasParam(cfg); err == nil {
			if err := q.DecodeParam(cfg, func(d uri.Decoder) error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.Action = ProcessLeaveRequestsAction(c)
				return nil
			}); err != nil {
				return params, errors.Wrap(err, "query: action: parse")
			}
			if err := func() error {
				if err := params.Action.Validate(); err != nil {
					return err
				}
				return nil
			}(); err != nil {
				return params, errors.Wrap(err, "query: action: invalid")
			}
		} else {
			return params, errors.Wrap(err, "query")
		}
	}
	// Decode path: id.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "id",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToString(val)
				if err != nil {
					return err
				}

				params.ID = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: id: not specified")
		}
	}
	return params, nil
}

type PutGroupsGroupIdParams struct {
	// Unique identifier for the group within Rippling.
	GroupId int
}

func decodePutGroupsGroupIdParams(args [1]string, r *http.Request) (params PutGroupsGroupIdParams, _ error) {
	// Decode path: groupId.
	{
		param := args[0]
		if len(param) > 0 {
			d := uri.NewPathDecoder(uri.PathDecoderConfig{
				Param:   "groupId",
				Value:   param,
				Style:   uri.PathStyleSimple,
				Explode: false,
			})

			if err := func() error {
				val, err := d.DecodeValue()
				if err != nil {
					return err
				}

				c, err := conv.ToInt(val)
				if err != nil {
					return err
				}

				params.GroupId = c
				return nil
			}(); err != nil {
				return params, err
			}
		} else {
			return params, errors.New("path: groupId: not specified")
		}
	}
	return params, nil
}
