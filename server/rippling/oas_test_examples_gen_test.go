// Code generated by ogen, DO NOT EDIT.

package rippling

import (
	"fmt"

	"github.com/go-faster/errors"
	"github.com/go-faster/jx"

	"github.com/ogen-go/ogen/validate"

	std "encoding/json"
	"testing"

	"github.com/stretchr/testify/require"
)

func TestAddress_EncodeDecode(t *testing.T) {
	var typ Address
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Address
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestAuthenticatedUserMe_EncodeDecode(t *testing.T) {
	var typ AuthenticatedUserMe
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 AuthenticatedUserMe
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestAuthenticatedUserMe_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"company\":\"5ec5595afa9c4e1728118cb5\",\"id\":\"5ec5595dfa9c4e1728118d11\",\"workEmail\":\"cpitt+2@rippling.com\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ AuthenticatedUserMe

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				var validateErr *validate.Error
				if errors.As(err, &validateErr) {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 AuthenticatedUserMe
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestCandidate_EncodeDecode(t *testing.T) {
	var typ Candidate
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Candidate
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCandidateAttachmentsItem_EncodeDecode(t *testing.T) {
	var typ CandidateAttachmentsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CandidateAttachmentsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCandidateEmploymentType_EncodeDecode(t *testing.T) {
	var typ CandidateEmploymentType
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CandidateEmploymentType
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCandidateSalaryUnit_EncodeDecode(t *testing.T) {
	var typ CandidateSalaryUnit
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CandidateSalaryUnit
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCompany_EncodeDecode(t *testing.T) {
	var typ Company
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Company
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestCompany_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"address\":{\"city\":\"string\",\"country\":\"string\",\"state\":\"string\",\"streetLine1\":\"string\",\"streetLine2\":\"string\",\"zip\":\"string\"},\"id\":\"string\",\"name\":\"string\",\"phone\":\"string\",\"primaryEmail\":\"string\",\"workLocations\":[{\"address\":{\"city\":\"string\",\"country\":\"string\",\"state\":\"string\",\"streetLine1\":\"string\",\"streetLine2\":\"string\",\"zip\":\"string\"},\"id\":\"string\",\"nickname\":\"string\"}]}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ Company

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				var validateErr *validate.Error
				if errors.As(err, &validateErr) {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 Company
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestCustomFields_EncodeDecode(t *testing.T) {
	var typ CustomFields
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CustomFields
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestCustomFieldsType_EncodeDecode(t *testing.T) {
	var typ CustomFieldsType
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 CustomFieldsType
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestDepartment_EncodeDecode(t *testing.T) {
	var typ Department
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Department
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestEmployee_EncodeDecode(t *testing.T) {
	var typ Employee
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Employee
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestEmployee_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"customFields\":{\"Id\":\"string\",\"required\":true,\"title\":\"string\",\"type\":\"TEXT\"},\"department\":\"string\",\"employmentType\":\"CONTRACTOR\",\"endDate\":\"string\",\"firstName\":\"string\",\"gender\":\"MALE\",\"id\":\"string\",\"identifiedGender\":\"MALE\",\"lastName\":\"string\",\"manager\":\"string\",\"name\":\"string\",\"photo\":\"string\",\"roleState\":\"INIT\",\"smallPhoto\":\"string\",\"spokeId\":\"string\",\"title\":\"string\",\"workEmail\":\"string\",\"workLocation\":{\"city\":\"string\",\"country\":\"string\",\"state\":\"string\",\"streetLine1\":\"string\",\"streetLine2\":\"string\",\"zip\":\"string\"}}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ Employee

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				var validateErr *validate.Error
				if errors.As(err, &validateErr) {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 Employee
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestEmployeeEmploymentType_EncodeDecode(t *testing.T) {
	var typ EmployeeEmploymentType
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 EmployeeEmploymentType
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestEmployeeGender_EncodeDecode(t *testing.T) {
	var typ EmployeeGender
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 EmployeeGender
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestEmployeeIdentifiedGender_EncodeDecode(t *testing.T) {
	var typ EmployeeIdentifiedGender
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 EmployeeIdentifiedGender
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestEmployeeRoleState_EncodeDecode(t *testing.T) {
	var typ EmployeeRoleState
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 EmployeeRoleState
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestEvent_EncodeDecode(t *testing.T) {
	var typ Event
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Event
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestEventEventReason_EncodeDecode(t *testing.T) {
	var typ EventEventReason
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 EventEventReason
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestEventEventType_EncodeDecode(t *testing.T) {
	var typ EventEventType
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 EventEventType
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestEventInitiator_EncodeDecode(t *testing.T) {
	var typ EventInitiator
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 EventInitiator
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestEventInitiatorType_EncodeDecode(t *testing.T) {
	var typ EventInitiatorType
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 EventInitiatorType
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestEventRequestData_EncodeDecode(t *testing.T) {
	var typ EventRequestData
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 EventRequestData
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestEventSubjectsItem_EncodeDecode(t *testing.T) {
	var typ EventSubjectsItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 EventSubjectsItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestEventSubjectsItemType_EncodeDecode(t *testing.T) {
	var typ EventSubjectsItemType
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 EventSubjectsItemType
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGetCompanyActivityOK_EncodeDecode(t *testing.T) {
	var typ GetCompanyActivityOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetCompanyActivityOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestGetCompanyActivityOK_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"data\":{\"events\":[{\"company\":\"595f75ffd2a5f80ae22ce88e\",\"event_reason\":{\"message\":\"Activity emanated from External App\",\"reason\":\"CHANGE_SYNCED_FROM_EXTERNAL_APP\"},\"event_type\":\"EXTERNAL_GROUP_MEMBER_REMOVE\",\"id\":\"5ed7052182a6a429a4af3fb9\",\"initiator\":{\"display_name\":\"External\",\"icon\":null,\"role\":null,\"type\":\"EXTERNAL\"},\"linked_events\":[],\"name\":\"Account removed from group\",\"owner\":\"5c63232bc5929135ddadbfab\",\"request_data\":null,\"spoke\":\"5c63187a3698be3692ce328f\",\"subjects\":[{\"display_name\":\"Everyone\",\"icon\":null,\"instance\":\"5c6324b602bf9a760b7a4329\",\"type\":\"GROUP\"},{\"display_name\":\"apps+test@rippling.com\",\"icon\":null,\"instance\":\"5c6324b502bf9a760b7a4318\",\"type\":\"SPOKE_USER\"},{\"display_name\":\"Swag Test\",\"icon\":null,\"instance\":\"5ca35d3b6ab9e20acc4e83e3\",\"type\":\"ROLE\"}],\"timestamp\":\"2020-06-02T19:04:17.375000-07:00\"}],\"next\":\"5f4d9d82f6c26e0a83aa6ea8\"},\"error\":null}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ GetCompanyActivityOK

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				var validateErr *validate.Error
				if errors.As(err, &validateErr) {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 GetCompanyActivityOK
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestGetCompanyActivityOKData_EncodeDecode(t *testing.T) {
	var typ GetCompanyActivityOKData
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GetCompanyActivityOKData
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestGroup_EncodeDecode(t *testing.T) {
	var typ Group
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Group
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestGroup_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"id\":\"5f397f3b3ca04e478d4575ad\",\"name\":\"GroupTest\",\"spokeId\":\"lkjwbfskjsdbllskdb\",\"users\":[],\"version\":\"yvmzhfw50hn39aas\"}"},
		{Input: "{\"id\":\"5f397f3b3ca04e478d4575ad\",\"name\":\"GroupTest4\",\"spokeId\":\"lkjwbfskjsdbllskdb\",\"users\":[\"5c8f7f06c592917aeee1ea9f\"],\"version\":\"uu8ccavwbsb8stfn\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ Group

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				var validateErr *validate.Error
				if errors.As(err, &validateErr) {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 Group
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestGroupUpdatePayload_EncodeDecode(t *testing.T) {
	var typ GroupUpdatePayload
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 GroupUpdatePayload
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestGroupUpdatePayload_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"name\":\"GroupTest\",\"spokeId\":\"lkjwbfskjsdbllskdb\",\"users\":[\"\"],\"version\":\"uu8ccavwbsb8stfn\"}"},
		{Input: "{\"name\":\"GroupTest\",\"spokeId\":\"lkjwbfskjsdbllskdb\",\"users\":[],\"version\":\"yvmzhfw50hn39aas\"}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ GroupUpdatePayload

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				var validateErr *validate.Error
				if errors.As(err, &validateErr) {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 GroupUpdatePayload
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestLeaveRequest_EncodeDecode(t *testing.T) {
	var typ LeaveRequest
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 LeaveRequest
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestLeaveRequestDatesItem_EncodeDecode(t *testing.T) {
	var typ LeaveRequestDatesItem
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 LeaveRequestDatesItem
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestLeaveRequestLeaveType_EncodeDecode(t *testing.T) {
	var typ LeaveRequestLeaveType
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 LeaveRequestLeaveType
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestLeaveRequestStatus_EncodeDecode(t *testing.T) {
	var typ LeaveRequestStatus
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 LeaveRequestStatus
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestLevel_EncodeDecode(t *testing.T) {
	var typ Level
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Level
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestPostGroupsReq_EncodeDecode(t *testing.T) {
	var typ PostGroupsReq
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostGroupsReq
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}

func TestPostGroupsReq_Examples(t *testing.T) {

	for i, tc := range []struct {
		Input string
	}{
		{Input: "{\"name\":\"GroupTest4\",\"spokeId\":\"lkjwbfskjsdbllskdb\",\"users\":[\"5c8f7f06c592917aeee1ea9f\"]}"},
	} {
		tc := tc
		t.Run(fmt.Sprintf("Test%d", i+1), func(t *testing.T) {
			var typ PostGroupsReq

			if err := typ.Decode(jx.DecodeStr(tc.Input)); err != nil {
				var validateErr *validate.Error
				if errors.As(err, &validateErr) {
					t.Skipf("Validation error: %v", validateErr)
					return
				}
				require.NoErrorf(t, err, "Input: %s", tc.Input)
			}

			e := jx.Encoder{}
			typ.Encode(&e)
			require.True(t, std.Valid(e.Bytes()), "Encoded: %s", e.Bytes())

			var typ2 PostGroupsReq
			require.NoError(t, typ2.Decode(jx.DecodeBytes(e.Bytes())))
		})
	}
}
func TestPostMarkAppInstalledOK_EncodeDecode(t *testing.T) {
	var typ PostMarkAppInstalledOK
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 PostMarkAppInstalledOK
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestTeam_EncodeDecode(t *testing.T) {
	var typ Team
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 Team
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
func TestWorkLocation_EncodeDecode(t *testing.T) {
	var typ WorkLocation
	typ.SetFake()

	e := jx.Encoder{}
	typ.Encode(&e)
	data := e.Bytes()
	require.True(t, std.Valid(data), "Encoded: %s", data)

	var typ2 WorkLocation
	require.NoError(t, typ2.Decode(jx.DecodeBytes(data)))
}
